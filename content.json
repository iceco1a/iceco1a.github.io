{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/01/18/hello-world/"},{"title":"Java IO流","text":"简介 Java的IO通过java.io包下的类和接口来支持，在java.io包下主要包括输入、输出流又可分为字节流和字符流两大类。其中字节流以字节为单位来处理输入和输出操作，而字符流以字符来处理输入和输出操作。此外Java的IO流使用了装饰器设计模式，它将IO流分为底层节点流和上层处理流，其中节点流和底层的物理存储节点直接关联——不同的物理节点获取节点流的方式存在差异，但程序可以把不同的物理节点包装成统一的处理流，从而允许程序使用统一的输入、输出代码来读取不同的物理存储节点的资源.Java7在java.nio及其子包下提供了一系列全新的API，这些API是对原有新IO的升级，因此也被称为NIO2，通过这些NIO2，程序可以更高效地进行输入、输出操作。除此之外，Java还使用了对象的序列化机制，通过序列化机制可以把内存中的Java对象转换成二进制字节流，这样就可以把Java对象存储到磁盘里，或者在网络上传输Java对象。 File类File类是java.io包下代表和平台无关的文件和目录，不管是文件还是目录DOI是使用File来操作的，File能创建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入流、输出流 访问文件和目录File类可以使用文件路径字符串来创建File实例该文件路径既可以是绝对路径，也可以是相对路径。在默认情况下，系统总是根据用户的工作路径来解释相对路径一旦创建了File对象，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录 1.访问文件名相关的方法 String getName():返回此File对象表示的文件名或者路径名 String getPath():返回此File对象所对应的路径名 File getAbsoultFile()：返回此File对象的绝对路径 String getParent()：返回此File对象所对应目录的父目录名。 boolean renameTo(File newName):重命名此File对象所对应的文件或者目录，如果重命名成功，则返回true，否则返回false。 2.文件检测相关 boolean exists()；判断File对象所对应的文件或者目录是否存在 boolean canWrite():判断File对象所对应的文件和目录是否能写 boolean canRead():判断按File对象所对应的文件和目录是否能读 boolean isFile()：判断File对象所对应的是否文件，而不是目录 boolean isDirectory()：判断File对象是否是目录，而不是文件 boolean isAbsolute():判断File对象所对应的文件和目录是否是绝对路径。该方法消除了平台差异，可以直接判断File对象是否为绝对路径。在Unix/Linux/BSD系统上，如果路径名开头是一条斜线，则表明该File对象是一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径 3.获取常规文件信息 long lastModified():返回文件最后的修改时间 long length():返回文件内容的长度 4.文件操作相关 boolean createNewFile();当此filed对象所对应的文件不存在时，该方法将新建一个该file对象所指定的新文件，如果创建成功则返回true，否则返回false boolean delete()：删除File对象所对应的文件或者路径 static File createTempFile(String prefix,String suffix):在默认的临时文件目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接使用File类来调用。prefix参数必须至少是3字节长。建议前缀使用一个短的，有意义的字符串，如“mail”后缀参数可以是null，在这种情况下默认的后缀是“.tmp” static File createTempFile(String prefix,String suffix,File directory):在directory所指定的目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接通过File类来调用 void deleteOnExit():注册一个删除钩子，当Java虚拟机退出时候，删除File对象所对应的文件和目录 5.目录操作相关的方法 boolean mkdir():试图创建一个File对象对应的目录。调用该方法时File对象必须是一个路径，而不是一个文件 String[] list():列出File对象的所有字文件名和路径名，返回String数组 File[] listFile():列出File对象所有子文件和路径，返回File数组 static File[] listRoots():列出系统所有的根目录。 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file.getName()); System.out.println(file.getParent()); System.out.println(file.getAbsoluteFile()); //获取的是string，上面的获取的是file System.out.println(file.getAbsolutePath()); System.out.println(file.getAbsoluteFile().getParent()); //在当前目录下车间一个临时文件 File tmpfile=File.createTempFile(\"aaa\",\".txt\",file); //当jvm退出时候删除此文件 tmpfile.deleteOnExit(); //以系统当前时间作文新文件名来创建新文件 File newFile = new File(System.currentTimeMillis()+\"\"); System.out.println(newFile.exists()); //以指定newFile对象来创建一个文件 newFile.createNewFile(); //以newFile对象来创建一个目录，因为newFile已经存在所以下面方法返回false，即无法创建该目录 newFile.mkdir(); //使用list方法列出当前路径下的所有文件和路径 System.out.println(\"---------\"); String[] filelist = file.list(); for (String filename:filelist){ System.out.println(filename); } System.out.println(\"---------\"); //listroot()静态方法查看所有的根目录 File[] roots = File.listRoots(); for (File root:roots){ System.out.println(root); } }}/* 程序列出当前文件和路径时，列出了程序创建的临时文件，但程序运行结束后，aaa.txt 并不存在，因为程序制定虚拟机退出时自动删除了该文件。上面程序还有一点要注意的是 当使用相对路径的File对象来获取父类路径的时候可能会出差，因为该方法返回将File对象 所对应的目录名、文件名里最后一个子目录名、子文件名删除后的结果 */ 文件过滤器在File类的list()方法中可以接收一个FilenameFilter参数，通过该参数只列出符合条件的文件，FilenameFilter接口里包含了一个accept(File dir,String name)方法，该方法将依次对指定File的所有子目录或者文件进行迭代，如果返回true，则list()方法会列出子目录或者文件123456789101112import java.io.File;public class FilenameFilterTest { public static void main(String[] args) { File file = new File(\".\"); //使用lambda表达式，（目标类型是FilenameFilter）实现文件过滤 String[] nameList = file.list((dir,name)-&gt;name.endsWith(\".java\")|| new File(name).isDirectory()); for (String name:nameList){ System.out.println(name); } }} 上面的程序部分实现了accept()方法，实现accept()方法就是指定自己的规则，指定哪些文件由list()方法列出。FilenameFilter接口内只有一个抽象方法，因此该接口也是一个函数式接口，可使用lambda表达式创建实现该接口的对象 理解Java的IO流 Java的IO流是实现输入、输出的基础，可以方便得实现数据的输入输出操作，在Java中把不同的输出输出源抽象表述为“流”，通过流的方式允许Java程序使用相同的方式来访问不同的输入、输出源，Java中把所有传统的流类型都放在java.io包中，用以实现输入输出功能。 流的分类1.输入和输出流 输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能向其中写数据，而不能从中读取数据。 注：输入输出涉及到一个方向的问题，数据从内存到硬盘，通常称为输出流——也就是说，这里的输入输出都是从程序运行所在内存的角度而划分的。数据从服务器通过网络流向客户端，在这种情况下，Server端的内存负责将数据输出到网络当中，因此Server端使用的是输出流，Client端的内存负责从网络里读取数据，因此Client端的程序应该使用输入流。Java中的输入流主要由InputStream和Reader作为基类，而输出流主要由OutputStream和Writer作为基类。都是一些抽象基类，无法直接创建实例。 2.字节流和字符流字节流和字符流使用方法几乎一样，区别在于所操作的数据单元不同——字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符字节流主要由InputStream和OutputStream作为基类，而字符流主要由Reader和Writer作为基类。 3.节点流和处理流按照流的角色来分，可以分为节点流和处理流可以从/向一个特定的IO设备(如磁盘、网络)读/写数据的流，称为节点流，节点流也被称为低级流使用节点流进行输入、输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。处理流则是用于对一个已经存在的流进行连接或者封装，通过封装后的流实现读写数据的功能，也被称为高级流。使用处理流的时候，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入输出代码来访问不同的数据源，随着处理流包装节点流的变化，程序实际所访问的数据源也相应地发生变化。注：Java使用处理流来包装节点是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来玩成输入、输出功能。因此处理流也被称为包装流 流的模型概念Java把所有设备里有序数据抽象成流模型，简化了输出、输出处理，Java的IO流涉及了40多个类，都是由如下4个抽象基类派生的。 InputStream/Reader 所有输入流的基类，前者是字节输入流，后者是字符输入流 OutputStream/Writer：所有输出流的基类前者是字节输出流，后者是字符输出流。 处理流的功能主要体现在以下两个方面 性能的提高：主要以增加缓冲的方式来提高输入/输出效率。 操作的便捷：处理流可能提供一系列便捷的方法来一次输入/输出大批量的内容，而不是一个 处理流可以“嫁接”在任何已经存在的流的基础之上，这就允许Java应用程序采用相同的代码、透明的方式来访问不同的输入/输出设备的数据流。通过使用处理流，Java程序无需理会输入/输出节点是磁盘、网络还是其他的输入输出设备，程序只要将这些节点包装成处理流，就可以使用相同的输入/输出代码来读写不同的输入/输出设备的数据 字节流和字符流InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可以使用的方法在InputStream里包含如下三个方法 int Read():从输入流中读取单个字节，返回所读取的字节数据（字节数据可以直接转换为int类型） int Read(byte[] b):从输入流中最多读取b.length()个字节数据，并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[] b,int off,int len)从输入流中最多读取len个字节数据，并将其存储在b数组中，从off开始读写。 Read中的三个基本方法 int Read():从输入流中读取单个字符，返回所读取的字符数据(字符数据可以直接转换为int类型) int Read(char[] cbuf): int Read(char[] cbuf,int off,int len); 以上两个方法都是其方法返回值为-1时候，表示输入流的终点。InputStream和Reader都是抽象类，本身不能创建实例，但它们分别都有一个用于读取文件的输入流FileInputStream和FileReader，它们都是节点流——会直接和指定文件关联 12345678910111213141516import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamTest { public static void main(String[] args) throws IOException { //创建字节输入流 FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); //创建一个长度为1024的数组 byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = fis.read(bbuf)) &gt;0){ System.out.println(new String(bbuf,0,hasRead)); } fis.close(); }} 注：上面的代码创建了一个长度为1024的字节数组来读取该文件，也就是说，程序只需要执行一次read()就能读取全部内容。但如果创建较小长度的字节数组，程序在运行时候输出中文注释的时候就会出现乱码————这是因为文件保存时候采用的是GBK编码方式，在这种方式下，每个中文字符占2个字节，如果只读取了半个中文字符，就会导致乱码 123456789101112131415161718import java.io.FileReader;import java.io.IOException;public class FileReaderTest { public static void main(String[] args) { try( FileReader fr = new FileReader(\"./IO/src/FileReaderTest.java\")){ //创建一个长度为32的char数组 char[] cbuf = new char[32]; int hasRead = 0; while ((hasRead=fr.read(cbuf))&gt;0){ System.out.println(new String(cbuf,0,hasRead)); } }catch (IOException io){ io.printStackTrace(); } }} FileReaderTest.java和以上的程序并没有太大的不同，程序只是将字符数组长度改成了32，意味着程序要多次调用read()方法才可能完全读取输入流的全部数据。程序最终使用了自动关闭资源的try语句来关闭文件的输入流，此外InputStream和Reader还支持如下几种方式来移动记录指针 void mark(int c):将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字符。 boolean markSupported():判断此输入流是否支持mark操作，即是否支持记录标记 void reset()：将此流记录指针重新定位到上一次记录标记mark的位置 long skip(long n)：记录指针向前移动n个字符/字节 OutputStream和Witer void write(int c):将指定的字节/字符输出到输出流中，其中c即可代表字节，也可以代表字符 void write(byte[]/char[] buff):将字符数组/字节数组的数据输出到指定输出流中 void write(byte[]/char[] buff,int off,int len):将字节数组/字符数组从off位置开始，长度为len的字节/字符输出到输出流中。 因为字符流操作直接是以字符为操作单位，所以Writer可以使用字符串来代替字符数组，Writer还包含如下两个方法。 void write(String str):将str字符串里包含的字符输出到指定的输出流中 void write(String str,int off,int len):将str字符串里从off开始输出到指定的输出流中去。 下面的程序使用FileInputStream来执行输入，并使用FileOutPutStream来输出123456789101112131415161718import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamTest { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); FileOutputStream fos = new FileOutputStream(\"newfile.txt\")){ byte[] bbuf = new byte[32]; int hasRead = 0; while ((hasRead=fis.read(bbuf))&gt;0){ fos.write(bbuf,0,hasRead); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 注：使用Java的IO执行输出的时候，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区的数据flush到物理节点（因为在执行close()方法之前，自动执行输出流flush()方法）。Java中很多输出流默认都提供了缓存功能，无需刻意记忆哪些流有缓冲功能、哪些没有、只要正常关闭所有的输出流即可保证程序正常。 如果希望直接输出字符串内容，使用Writer效果会好一点12345678910111213import java.io.FileWriter;import java.io.IOException;public class FileWriterTest { public static void main(String[] args) { try(FileWriter fw = new FileWriter(\"poem.txt\")){ fw.write(\"锦瑟\"); fw.write(\"锦瑟无端五十弦，一弦一柱思华年。\\r\\n\"); fw.write(\"庄生晓梦迷蝴蝶，望帝春心托杜鹃.\\r\\n\"); }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序在输出字符串内容的时候，字符串后面是\\r\\n,这是Windows平台的换行符，通过这种方式就可以让输出内容换行，如果是Linux/Unix/BSD等平台，则使用\\n作为换行符即可 输入/输出流体系上面介绍了4个文件的节点流的使用方法，但是4个基类使用有些繁琐，简化开发，就需要使用到了处理流了。 处理流的用法处理流可以隐藏底层设备上的节点流的差异，并对外提供更加方便的输入/输出方法。使用处理流思路是，使用处理流来保证节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的I/O设备，文件交互。实际识别处理流十分简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流；而所有节点流都是直接以物理IO节点作为构造器参数的。 使用处理流的优势1.对于开发人员来说，使用处理流进行输入/输出操作更加简单。2.使用处理流的执行效率更高 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class PrintStreamTest { public static void main(String[] args) { try( FileOutputStream fos = new FileOutputStream(\"text.txt\"); PrintStream ps = new PrintStream(fos); ){ //使用PrintStream执行输出 ps.println(\"普通字符\"); //直接使用PrintStream输出对象 ps.println(new PrintStreamTest()); } catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中定义了一个节点输出流FileOutputStream, 然后程序使用PrintStream包装了该节点输出流，最后使用PrintStream输出字符串、输出对象..PrintStream的输出功能非常强大，标准输出System.out的类型就是PrintStream。在使用处理流包装了底层节点流之后，关闭输入/输出流资源时，只要关闭最上层的处理流即可。关闭最上层的处理流时，系统会自动关闭被该处理流包装的节点流。 输入/输出体系java的输入输出体系提供了接近40个类，之所以如此复杂是因为实现更好的设计，把IO流按功能分成了很多的类，而每个类有分别提供了字节流和字符流，字节流字符流又分为输入流输出流两大类。 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream FilterOutPutStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInptStream DataOutputStream 通常来说，字节流的功能比字符流的功能强大的多，因为计算机中数据大多数是二进制文件。问题是如果使用字节流来处理文本，则需要使用合适的方式把字节字节转换为字符，会增加编程的难度。所以通常有一个规则：如果进行输入/输出的内容是文本内容，则应该考虑使用字符流；如果进行输入/输出的内容是二进制内容，就应该考虑使用字节流 上面的表中还列出了以数组为物理节点的字节流，字节流以字节数组为节点，字符流以字符数组为节点；这种数组为物理节点的节点流消除了创建节点流对象时，需要传入应该字节数组或者字符数组之外，用法上与文件节点流完全相似。字符流还可以使用字符串作为物理节点，用于实现从字符串读取内容，或将内容写入字符串（StringBuffer充当字符串），下面程序示范了使用字符串作为物理节点的字符输入/输出流的用法 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;public class StringNodeTest { public static void main(String[] args) { String src = \"从明天起，做一个幸福的人\\n\" + \"喂马劈柴，周游世界\\n\" + \"从明天起，关心粮食和蔬菜\\n\" + \"我有一所房子，面朝大海，春暖花开\\n\"; char[] buff = new char[32]; int hasRead = 0; try ( StringReader sr = new StringReader(src)) { while ((hasRead = sr.read(buff)) &gt; 0) { System.out.println(new String(buff, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } try ( //创建StringWriter时，实际上以一个StringBuffer作为输出节点 //下面就是指定的20就是StringBuffer的初始长度 StringWriter sw = new StringWriter() ) { sw.write(\"有一个美丽的世界\"); sw.write(\"她在远方等我\"); sw.write(\"那里有天真的孩子\"); sw.write(\"还有姑娘的酒窝\"); System.out.println(\"------下面是sw字符串节点里的内容-----\"); System.out.println(sw.toString()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序与前面使用FileReader和FileWriter的程序基本相似，只是在创建StringReader和StringWriter对象时传入的是字符串节点，而不是文件节点。由于String是不可变的字符串对象，所以StringWriter使用StringBuffer作为输出节点。 转换流输入/输出流体系中还提供了两个转换流，这两个转换流用于实现将字节流转换成字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter 将字节输出流转换成字符输出流。 问：为什么没有把字符流转换为字节流的转换流？ 想一想字符流和字节流的差别:字节流比字符流的使用范围更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢?反之，如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以Java只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。 12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class KeyinTest { public static void main(String[] args) { try ( //将System.in对象转换为Reader对象 InputStreamReader reader = new InputStreamReader(System.in); //将普通的Reader包装成BufferedReader BufferedReader br = new BufferedReader(reader) ) { String line = null; //采取循环的方式来读取 while ((line = br.readLine()) != null) { //如果读取字符串是exit，则程序退出 if (line.equals(\"exit\")) { System.exit(1); } //打印读取内容 System.out.println(\"输入内容：\" + line); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中 的粗体字代码负责将System.in包装成BufferedReader, BufferedReader流具有缓冲功能，它可以一次读取一行文本——一以换行符为标志， 如果它没有读到换行符，则程序阻塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时,只有按下回车键,程序才会打印出刚刚输入的内容。由于BufferedReader具有一个readLine()方法，可以非常方便地一次读入一行内容，所以经常把读取文本内容的输入流包装成BufferedReader,用来方便地读取输入流的文本内容。 推回输入流在输入/输出流体系中，有两个特殊的流与众不同，就是PushbackInputStream和PushbackReader,它们都提供了如下三个方法。 void unread(byte[]/char[]bu):将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(byte[]/char[] b, int off, int len);将一个字 节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(intb):将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区里，而推回输入流每次调用read()方法时总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流中读取。当程序创建一个PushbackInputStream和PushbackReader时需要指定推回缓冲区的大小，默认的推回缓冲区的长度为1。如果程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileReader;import java.io.IOException;import java.io.PushbackReader;public class PushbackTest { public static void main(String[] args) { try ( //创建一个PushbackReader对象，指定推回缓冲区的长度为64 PushbackReader pr = new PushbackReader(new FileReader(\"./IO/src/PushbackTest.java\"), 64); ) { char[] buff = new char[32]; // 用以保存上次读取的字符串内容 String lastContent = \"\"; int hasRead = 0; //循环读取文件 while ((hasRead = pr.read(buff)) &gt; 0) { //将读取的内容转换为字符串 String content = new String(buff, 0, hasRead); int targetIndex = 0; //将上次读取的字符串和本次读取的字符串拼接起来 if ((targetIndex = (lastContent + content).indexOf(\"new PushbackReader\")) &gt; 0) { //将本次内容和上次内容一起推回缓冲区 pr.unread((lastContent + content).toCharArray()); //重新定义一个长度为targetIndex的char数组 if (targetIndex &gt; 32) { buff = new char[targetIndex]; } //再次读取指定长度的内容（就是目标字符串之前的内容） pr.read(buff, 0, targetIndex); //打印读取的内容 System.out.println(new String(buff, 0, targetIndex)); System.exit(0); } else { //打印上次读取的内容 System.out.println(lastContent); //将本次内容设为上次读取的内容 lastContent = content; } } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的粗体字代码实现了将指定内容推回到到推回缓冲区，于是当程序再次调用read方法时，实际上只读取了推回缓冲区的部分内容，从而实现了只打印目标字符串前面的内容 重定向标准输入/输出Java 的标准输入/输出分别通过System.in和System.out来代表，在默认情况下它们分别代表键盘和显示器，程序通过System.in来获取输入时，实际上是从键盘读取输入;当程序试图通过Syste m.out执行输出时，程序总是输出到屏幕。 在System类里提供了如下三个重定向标准输入/输出的方法。 static void setErr(PrintStreamer):重定向“标准”错误输出流。 static void setIn(InputStream in):重定向“标准”输入流。 static void setOut(PrintStream out):重定向“标准”输出流。 下面程序通过重定向标准输出流，将System.out的输出重定向到文件输出，而不是在屏幕上输出。 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class RedirectOut { public static void main(String[] args) { try ( //一次性创建printStream输出流 PrintStream ps = new PrintStream(new FileOutputStream(\"out.txt\")) ) { //将标准流定向到ps System.setOut(ps); System.out.println(\"普通字符串\"); //向标准输出一个对象 System.out.println(new RedirectOut()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 下面程序采用重定向标准输入，从而可以将System.in重定向到指定文件，而不是键盘输入。123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.IOException;import java.util.Scanner;public class RedirectIn { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/RedirectIn.java\") ){ System.setIn(fis); //使用System.in创建Scanner对象，用于获取标准输入 Scanner sc = new Scanner(System.in); //增加下面一行只把回车作为分隔符 sc.useDelimiter(\"\\n\"); //判断下面一行是否还有输出项目 while (sc.hasNext()){ //输入输出项 System.out.println(\"键盘输入的内容是\"+sc.next()); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中的粗体字代码创建了一个FileInputStream输入流,并使用System的setln()方法将系统标准输入重定向到该文件输入流。运行上面程序，程序不会等待用户输入，而是直接输出了Redireetnjava文件的内容，这表明程序不再使用键盘作为标准输入，而是使用Redirectln.java文件作为标准输入源。 Java虚拟机读写其他进程的数据使用Runtime对象的exec()方法可以运行平台上的其他程序，该法产生一个Process对象，Process对象代表由该Java程序启动的子进程。Process 类提供了如下三个方法，用于让程序和其子进程进行通信。 InputStream getErrorStream():获取子进程的错误流。 InputStream getlnputStream():获取子进程的输入流。 InputStream getOutputStream():获取子进程的输出流。 如果试图让子程序读取程序中的数据，那么应该使用的是输出流。因为站在Java程序的角度来看，子进程读取Java程序的数据，就是让Java程序吧数据输出到子程序中（就像把数据输出到文件中一样，只是现在由子进程代替了文件节点），所以应该使用输出流。 RandomAccessFileRandomAccessFile是Java输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是，只需要访问文件部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。 与OutputStream、 Writer等输出流不同的是，RandomAccessFile 允许自由定位文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile. RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他10节点。 RandomAccessFile对象也包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件记录指针位于文件头(也就是0处)，当读/写了n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由移动该记录指针,既可以向前移动，也可以向后移动。RandomAccessFile 包含了如下两个方法来操作文件记录指针。 long getFilePointer):返回文件记录指针的当前位置。 void seek(long pos):将文件记录指针定位到pos位置。 RandomAccessFile既可以读文件，也可以写，所以它既包含了完全类似于InputStream的三个read()方法,其用法和InputStream的三个read()方法完全一样;也包含了完全类似于OutputStream的三个write()方法，其用法和OutputStream的三个write()方法完全一样。 除此之外，RandomAccessFile 还包含了一系列的readXxx()和writeXxx()方法来完成输入、输出。 RandomAccessFile类有两个构造器,其实这两个构造器基本相同,只是指定文件的形式不同而已一个使用String参数来指定文件名,一个使用File 参数来指定文件本身。除此之外,创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，该参数有如下4个值。 “r”: 以只读方式打开指定文件。如果试图对该RandomAccessFile 执行写入方法，都将抛出IOException异常。 “rw”: 以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。 “rws”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 “rwd”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。下面程序使用了RandomAccessFile来访问指定的中间部分数据。1234567891011121314151617181920212223import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileTest { public static void main(String[] args) { try ( RandomAccessFile raf = new RandomAccessFile(\"./IO/src/RandomAccessFileTest.java\", \"r\") ) { //获取RandomAccessFile对象文件指针的位置，初始位置为0 System.out.println(\"RandomAccessFile的文件指针的初始位置\" + raf.getFilePointer()); //移动raf的文件记录指针的位置 raf.seek(300); byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = raf.read(bbuf)) &gt; 0) { System.out.println(new String(bbuf, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的代码创建了一个RandomAccessFile对象，该对象以只读方式打开了RandomAccessFileTest.java文件,这意味着该RandomAccessFile对象只能读取文件内容,不能执行写入。程序中第二行粗体字代码将文件记录指针定位到300处，也就是说，程序将从300字节处开始读、写，程序接下来的部分与使用InputStream读取并没有太大的区别。运行上面程序，将看到程序只读取后面部分的效果。 下面程序示范了如何向指定文件后追加内容，为了追加内容,程序应该先将记录指针移动到文件最后，然后开始向文件中输出内容。12345678910111213141516import java.io.IOException;import java.io.RandomAccessFile;public class AppendContent { public static void main(String[] args) { try ( //1.以读写方式打开一个RandomAccessFile对象 RandomAccessFile raf = new RandomAccessFile(\"out.txt\", \"rw\"); ) { raf.seek(raf.length()); raf.write(\"追加的内容！\\r\\n\".getBytes()); } catch (IOException ioe) { ioe.printStackTrace(); } }} RandomAccessFile依然不能向文件的指定位置插入内容,如果直接将文件记录指针移动到中间某位置后开始输出，则新输出的内容会覆盖文件中原有的内容。如果需要向指定位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等把需要插入的数据写入文件后，再将缓冲区的内容追加到文件后面。 12345678910111213141516171819202122232425262728293031323334353637import java.io.*;public class InsertContext { public static void insert(String fileName, long pos, String insertContext) throws IOException { File tmp = File.createTempFile(\"tmp\", null); tmp.deleteOnExit(); try ( RandomAccessFile raf = new RandomAccessFile(fileName, \"rw\"); //使用临时文件来保存插入点后的数据 FileOutputStream tmpOut = new FileOutputStream(tmp); FileInputStream tmpIn = new FileInputStream(tmp); ) { raf.seek(pos); //-------下面代码将插入点之后的内容读入临时文件中保存 byte[] bbuf = new byte[64]; //用于保存实际读取的字节数 int hasRead = 0; //循环读取插入点后的数据 while ((hasRead=raf.read(bbuf))&gt;0){ tmpOut.write(bbuf,0,hasRead); } //下面代码用于插入 raf.seek(pos); raf.write(insertContext.getBytes()); //追加临时文件的内容 while((hasRead=tmpIn.read(bbuf))&gt;0){ raf.write(bbuf,0,hasRead); } } catch (IOException ioe) { ioe.printStackTrace(); } } public static void main(String[] args)throws IOException { insert(\"./IO/src/InsertContent.java\",45,\"插入的内容\\r\\n\"); }} 上面程序中 使用File的createTempFile(String prefix, String suffix)方法创建了一个临时文件(该临时文件将在JVM退出时被删除),用以保存被插入文件的插入点后面的内容。程序先将文件中插入点后的内容读入临时文件中,然后重新定位到插入点，将需要插入的内容添加到文件后面,最后将临时文件的内容添加到文件后面，通过这个过程就可以向指定文件、指定位置插入内容。每次运行上面程序，都会看到向InsertContentjava中插入了一行字符串。 多线程断点的网络下载工具(如FlashGet等)就可通过RandomAccessFile类来实现，所有的下载工具在下载开始时都会建立两个文件:一个是与被下载文件大小相同的空文件，一个是记录文件指针的位置文件，下载工具用多条线程启动输入流来读取网络数据, 并使用RandomAccessFile将从网络上读取的数据写入前面建立的空文件中，每写一些数据后，记录文件指针的文件就分别记下每个RandomAccessFile当前的文件指针位置一网络断开后，再次开始下载时，每个RandomAccessFile都根据记录文件指针的文件中记录的位置继续向下写数据。","link":"/2019/01/23/Java IO/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[]}