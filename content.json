{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/01/18/hello-world/"},{"title":"Redis","text":"简介redis是一款高性能的NOSQL系列的非关系型数据库 NOSQLNoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL和关系型数据库比较优点： 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点： 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品 键值(Key-Value)存储数据库相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB典型应用： 内容缓存，主要用于处理大量数据的高访问负载。数据模型： 一系列键值对优势： 快速查询劣势： 存储的数据缺少结构化 列存储数据库相关产品：Cassandra, HBase, Riak典型应用：分布式的文件系统数据模型：以列簇式存储，将同一列数据存在一起优势：查找速度快，可扩展性强，更容易进行分布式扩展劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 什么是RedisRedis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedsetredis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 命令操作macOS下直接使用homebrew安装启动Redis命令redis-server使用Redis命令行工具redis-cli基准测试工具redis-benchmarkAOF持久化文件检测工具和修复工具redis-check-aofRDB持久化文件检测工具和修复工具redis-check-dump redis的数据结构：redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构：(1)字符串类型string(2)哈希类型hash:map格式(3)列表类型list:linkedlist格式。支持重复元素(4)集合类型set:不允许重复元素(5)有序集合类型sortedset：不允许重复元素，且元素有顺序 字符串类型 string 1.存储： set key value 127.0.0.1:6379&gt; set username zhangsan OK 获取： get key 127.0.0.1:6379&gt; get username &quot;zhangsan&quot; 删除： del key 127.0.0.1:6379&gt; del age (integer) 1 哈希类型 hash 存储： hset key field value127.0.0.1:6379&gt; hset myhash username lisi(integer) 1127.0.0.1:6379&gt; hset myhash password 123(integer) 1 获取：hget key field: 获取指定的field对应的值127.0.0.1:6379&gt; hget myhash username&quot;lisi&quot;hgetall key：获取所有的field和value127.0.0.1:6379&gt; hgetall myhash(1) &quot;username&quot;(2) &quot;lisi&quot;(3) &quot;password&quot;(4) &quot;123&quot; 删除： hdel key field127.0.0.1:6379&gt; hdel myhash username(integer) 1 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 1. 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 `127.0.0.1:6379&gt; lpush myList a` `(integer) 1` `127.0.0.1:6379&gt; lpush myList b` `(integer) 2` `127.0.0.1:6379&gt; rpush myList c` `(integer) 3` 2. 获取： lrange key start end ：范围获取 `127.0.0.1:6379&gt; lrange myList 0 -1` `1) &quot;b&quot;` `2) &quot;a&quot;` `3) &quot;c&quot;` 3. 删除： `lpop key`： 删除列表最左边的元素，并将元素返回 `rpop key`： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 1. 存储：sadd key value `127.0.0.1:6379&gt; sadd myset a` `(integer) 1` `127.0.0.1:6379&gt; sadd myset a` `(integer) 0` 2. 获取：smembers key:获取set集合中所有元素 `127.0.0.1:6379&gt; smembers myset` `1) &quot;a&quot;` 3. 删除：srem key value:删除set集合中的某个元素 `127.0.0.1:6379&gt; srem myset a` `(integer) 1` 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 127.0.0.1:6379&gt; zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379&gt; zadd mysort 50 lisi (integer) 1 127.0.0.1:6379&gt; zadd mysort 80 wangwu (integer) 1 获取：zrange key start end [withscores] 127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 删除：zrem key value 127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 keys *: 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value持久化简介：redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件# after 900 sec (15 min) if at least 1 key changedsave 900 1# after 300 sec (5 min) if at least 10 keys changedsave 300 10# after 60 sec if at least 10000 keys changedsave 60 10000 重新启动redis服务器，并指定配置文件名称redis-server redis.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件 appendonly no（关闭aof） --&gt; appendonly yes （开启aof） `# appendfsync always ： 每一次操作都进行持久化` `appendfsync everysec ： 每隔一秒进行一次持久化` `# appendfsync no ： 不进行持久化` Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 使用步骤： 1. 下载jedis的jar包 2. 使用 123456//1. 获取连接Jedis jedis = new Jedis(\"localhost\",6379);//2. 操作jedis.set(\"username\",\"zhangsan\");//3. 关闭连接jedis.close(); 字符串类型 string12345678910@Test public void StringRedis(){ //存储 jedis.set(\"qijiang\",\"4396\"); //获取 String qijiang = jedis.get(\"qijiang\"); System.out.println(qijiang); //可以使用setex()方法存储可以指定过期时间的key value jedis.setex(\"activiecode\",60, \"4398\"); } 哈希类型 hash ： map格式 hset hget hgetAll123456789101112131415161718@Testpublic void HashRedis(){ //存储hash jedis.hset(\"user\",\"name\",\"hukai\"); jedis.hset(\"user\",\"age\",\"25\"); jedis.hset(\"user\",\"gender\",\"male\"); //获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); //获取hash中所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(\"user\"); //获取keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) { String value = user.get(key); System.out.println(key+\":\"+value); }} 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取1234567891011121314151617181920 //1. 获取连接Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口//2. 操作// list 存储jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//// list 范围获取List&lt;String&gt; mylist = jedis.lrange(\"mylist\", 0, -1);System.out.println(mylist);// list 弹出String element1 = jedis.lpop(\"mylist\");//cSystem.out.println(elemenString element2 = jedis.rpop(\"mylist\");//cSystem.out.println(elemen// list 范围获取List&lt;String&gt; mylist2 = jedis.lrange(\"mylist\", 0, -1);System.out.println(mylis//3. 关闭连接jedis.close(); 4) 集合类型set： 不允许重复元素 sadd smembers:获取所有元素12345678@Testpublic void SetRedis(){ //set存储 jedis.sadd(\"myset\",\"java\",\"php\",\"golang\"); //sert集合获取 Set&lt;String&gt; myset = jedis.smembers(\"myset\"); System.out.println(myset);} 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange12345678910@Test public void SortedSetRedis(){ //sortedset存储 jedis.zadd(\"mysortedset\",3, \"众星之子\"); jedis.zadd(\"mysortedset\",999,\"疾风剑豪\"); jedis.zadd(\"mysortedset\",30,\"德玛西亚皇子\"); //sortedSet获取 Set&lt;String&gt; mysortedset = jedis.zrange(\"mysortedset\", 0, -1); System.out.println(mysortedset); } jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,\"localhost\",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(\"hehe\",\"heihei\"); //4. 关闭 归还到连接池中 jedis.close();``` 连接池工具类 ``` javapublic class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is =JedisPoolUtils.class.getClassLoader() .getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"), Integer.parseInt(pro.getProperty(\"port\"))); } /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } }","link":"/2019/01/29/Redis/"},{"title":"Java IO流","text":"简介 Java的IO通过java.io包下的类和接口来支持，在java.io包下主要包括输入、输出流又可分为字节流和字符流两大类。其中字节流以字节为单位来处理输入和输出操作，而字符流以字符来处理输入和输出操作。此外Java的IO流使用了装饰器设计模式，它将IO流分为底层节点流和上层处理流，其中节点流和底层的物理存储节点直接关联——不同的物理节点获取节点流的方式存在差异，但程序可以把不同的物理节点包装成统一的处理流，从而允许程序使用统一的输入、输出代码来读取不同的物理存储节点的资源.Java7在java.nio及其子包下提供了一系列全新的API，这些API是对原有新IO的升级，因此也被称为NIO2，通过这些NIO2，程序可以更高效地进行输入、输出操作。除此之外，Java还使用了对象的序列化机制，通过序列化机制可以把内存中的Java对象转换成二进制字节流，这样就可以把Java对象存储到磁盘里，或者在网络上传输Java对象。 File类File类是java.io包下代表和平台无关的文件和目录，不管是文件还是目录DOI是使用File来操作的，File能创建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入流、输出流 访问文件和目录File类可以使用文件路径字符串来创建File实例该文件路径既可以是绝对路径，也可以是相对路径。在默认情况下，系统总是根据用户的工作路径来解释相对路径一旦创建了File对象，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录 1.访问文件名相关的方法 String getName():返回此File对象表示的文件名或者路径名 String getPath():返回此File对象所对应的路径名 File getAbsoultFile()：返回此File对象的绝对路径 String getParent()：返回此File对象所对应目录的父目录名。 boolean renameTo(File newName):重命名此File对象所对应的文件或者目录，如果重命名成功，则返回true，否则返回false。 2.文件检测相关 boolean exists()；判断File对象所对应的文件或者目录是否存在 boolean canWrite():判断File对象所对应的文件和目录是否能写 boolean canRead():判断按File对象所对应的文件和目录是否能读 boolean isFile()：判断File对象所对应的是否文件，而不是目录 boolean isDirectory()：判断File对象是否是目录，而不是文件 boolean isAbsolute():判断File对象所对应的文件和目录是否是绝对路径。该方法消除了平台差异，可以直接判断File对象是否为绝对路径。在Unix/Linux/BSD系统上，如果路径名开头是一条斜线，则表明该File对象是一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径 3.获取常规文件信息 long lastModified():返回文件最后的修改时间 long length():返回文件内容的长度 4.文件操作相关 boolean createNewFile();当此filed对象所对应的文件不存在时，该方法将新建一个该file对象所指定的新文件，如果创建成功则返回true，否则返回false boolean delete()：删除File对象所对应的文件或者路径 static File createTempFile(String prefix,String suffix):在默认的临时文件目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接使用File类来调用。prefix参数必须至少是3字节长。建议前缀使用一个短的，有意义的字符串，如“mail”后缀参数可以是null，在这种情况下默认的后缀是“.tmp” static File createTempFile(String prefix,String suffix,File directory):在directory所指定的目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接通过File类来调用 void deleteOnExit():注册一个删除钩子，当Java虚拟机退出时候，删除File对象所对应的文件和目录 5.目录操作相关的方法 boolean mkdir():试图创建一个File对象对应的目录。调用该方法时File对象必须是一个路径，而不是一个文件 String[] list():列出File对象的所有字文件名和路径名，返回String数组 File[] listFile():列出File对象所有子文件和路径，返回File数组 static File[] listRoots():列出系统所有的根目录。 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file.getName()); System.out.println(file.getParent()); System.out.println(file.getAbsoluteFile()); //获取的是string，上面的获取的是file System.out.println(file.getAbsolutePath()); System.out.println(file.getAbsoluteFile().getParent()); //在当前目录下车间一个临时文件 File tmpfile=File.createTempFile(\"aaa\",\".txt\",file); //当jvm退出时候删除此文件 tmpfile.deleteOnExit(); //以系统当前时间作文新文件名来创建新文件 File newFile = new File(System.currentTimeMillis()+\"\"); System.out.println(newFile.exists()); //以指定newFile对象来创建一个文件 newFile.createNewFile(); //以newFile对象来创建一个目录，因为newFile已经存在所以下面方法返回false，即无法创建该目录 newFile.mkdir(); //使用list方法列出当前路径下的所有文件和路径 System.out.println(\"---------\"); String[] filelist = file.list(); for (String filename:filelist){ System.out.println(filename); } System.out.println(\"---------\"); //listroot()静态方法查看所有的根目录 File[] roots = File.listRoots(); for (File root:roots){ System.out.println(root); } }}/* 程序列出当前文件和路径时，列出了程序创建的临时文件，但程序运行结束后，aaa.txt 并不存在，因为程序制定虚拟机退出时自动删除了该文件。上面程序还有一点要注意的是 当使用相对路径的File对象来获取父类路径的时候可能会出差，因为该方法返回将File对象 所对应的目录名、文件名里最后一个子目录名、子文件名删除后的结果 */ 文件过滤器在File类的list()方法中可以接收一个FilenameFilter参数，通过该参数只列出符合条件的文件，FilenameFilter接口里包含了一个accept(File dir,String name)方法，该方法将依次对指定File的所有子目录或者文件进行迭代，如果返回true，则list()方法会列出子目录或者文件123456789101112import java.io.File;public class FilenameFilterTest { public static void main(String[] args) { File file = new File(\".\"); //使用lambda表达式，（目标类型是FilenameFilter）实现文件过滤 String[] nameList = file.list((dir,name)-&gt;name.endsWith(\".java\")|| new File(name).isDirectory()); for (String name:nameList){ System.out.println(name); } }} 上面的程序部分实现了accept()方法，实现accept()方法就是指定自己的规则，指定哪些文件由list()方法列出。FilenameFilter接口内只有一个抽象方法，因此该接口也是一个函数式接口，可使用lambda表达式创建实现该接口的对象 理解Java的IO流 Java的IO流是实现输入、输出的基础，可以方便得实现数据的输入输出操作，在Java中把不同的输出输出源抽象表述为“流”，通过流的方式允许Java程序使用相同的方式来访问不同的输入、输出源，Java中把所有传统的流类型都放在java.io包中，用以实现输入输出功能。 流的分类1.输入和输出流 输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能向其中写数据，而不能从中读取数据。 注：输入输出涉及到一个方向的问题，数据从内存到硬盘，通常称为输出流——也就是说，这里的输入输出都是从程序运行所在内存的角度而划分的。数据从服务器通过网络流向客户端，在这种情况下，Server端的内存负责将数据输出到网络当中，因此Server端使用的是输出流，Client端的内存负责从网络里读取数据，因此Client端的程序应该使用输入流。Java中的输入流主要由InputStream和Reader作为基类，而输出流主要由OutputStream和Writer作为基类。都是一些抽象基类，无法直接创建实例。 2.字节流和字符流字节流和字符流使用方法几乎一样，区别在于所操作的数据单元不同——字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符字节流主要由InputStream和OutputStream作为基类，而字符流主要由Reader和Writer作为基类。 3.节点流和处理流按照流的角色来分，可以分为节点流和处理流可以从/向一个特定的IO设备(如磁盘、网络)读/写数据的流，称为节点流，节点流也被称为低级流使用节点流进行输入、输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。处理流则是用于对一个已经存在的流进行连接或者封装，通过封装后的流实现读写数据的功能，也被称为高级流。使用处理流的时候，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入输出代码来访问不同的数据源，随着处理流包装节点流的变化，程序实际所访问的数据源也相应地发生变化。注：Java使用处理流来包装节点是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来玩成输入、输出功能。因此处理流也被称为包装流 流的模型概念Java把所有设备里有序数据抽象成流模型，简化了输出、输出处理，Java的IO流涉及了40多个类，都是由如下4个抽象基类派生的。 InputStream/Reader 所有输入流的基类，前者是字节输入流，后者是字符输入流 OutputStream/Writer：所有输出流的基类前者是字节输出流，后者是字符输出流。 处理流的功能主要体现在以下两个方面 性能的提高：主要以增加缓冲的方式来提高输入/输出效率。 操作的便捷：处理流可能提供一系列便捷的方法来一次输入/输出大批量的内容，而不是一个 处理流可以“嫁接”在任何已经存在的流的基础之上，这就允许Java应用程序采用相同的代码、透明的方式来访问不同的输入/输出设备的数据流。通过使用处理流，Java程序无需理会输入/输出节点是磁盘、网络还是其他的输入输出设备，程序只要将这些节点包装成处理流，就可以使用相同的输入/输出代码来读写不同的输入/输出设备的数据 字节流和字符流InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可以使用的方法在InputStream里包含如下三个方法 int Read():从输入流中读取单个字节，返回所读取的字节数据（字节数据可以直接转换为int类型） int Read(byte[] b):从输入流中最多读取b.length()个字节数据，并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[] b,int off,int len)从输入流中最多读取len个字节数据，并将其存储在b数组中，从off开始读写。 Read中的三个基本方法 int Read():从输入流中读取单个字符，返回所读取的字符数据(字符数据可以直接转换为int类型) int Read(char[] cbuf): int Read(char[] cbuf,int off,int len); 以上两个方法都是其方法返回值为-1时候，表示输入流的终点。InputStream和Reader都是抽象类，本身不能创建实例，但它们分别都有一个用于读取文件的输入流FileInputStream和FileReader，它们都是节点流——会直接和指定文件关联 12345678910111213141516import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamTest { public static void main(String[] args) throws IOException { //创建字节输入流 FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); //创建一个长度为1024的数组 byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = fis.read(bbuf)) &gt;0){ System.out.println(new String(bbuf,0,hasRead)); } fis.close(); }} 注：上面的代码创建了一个长度为1024的字节数组来读取该文件，也就是说，程序只需要执行一次read()就能读取全部内容。但如果创建较小长度的字节数组，程序在运行时候输出中文注释的时候就会出现乱码————这是因为文件保存时候采用的是GBK编码方式，在这种方式下，每个中文字符占2个字节，如果只读取了半个中文字符，就会导致乱码 123456789101112131415161718import java.io.FileReader;import java.io.IOException;public class FileReaderTest { public static void main(String[] args) { try( FileReader fr = new FileReader(\"./IO/src/FileReaderTest.java\")){ //创建一个长度为32的char数组 char[] cbuf = new char[32]; int hasRead = 0; while ((hasRead=fr.read(cbuf))&gt;0){ System.out.println(new String(cbuf,0,hasRead)); } }catch (IOException io){ io.printStackTrace(); } }} FileReaderTest.java和以上的程序并没有太大的不同，程序只是将字符数组长度改成了32，意味着程序要多次调用read()方法才可能完全读取输入流的全部数据。程序最终使用了自动关闭资源的try语句来关闭文件的输入流，此外InputStream和Reader还支持如下几种方式来移动记录指针 void mark(int c):将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字符。 boolean markSupported():判断此输入流是否支持mark操作，即是否支持记录标记 void reset()：将此流记录指针重新定位到上一次记录标记mark的位置 long skip(long n)：记录指针向前移动n个字符/字节 OutputStream和Witer void write(int c):将指定的字节/字符输出到输出流中，其中c即可代表字节，也可以代表字符 void write(byte[]/char[] buff):将字符数组/字节数组的数据输出到指定输出流中 void write(byte[]/char[] buff,int off,int len):将字节数组/字符数组从off位置开始，长度为len的字节/字符输出到输出流中。 因为字符流操作直接是以字符为操作单位，所以Writer可以使用字符串来代替字符数组，Writer还包含如下两个方法。 void write(String str):将str字符串里包含的字符输出到指定的输出流中 void write(String str,int off,int len):将str字符串里从off开始输出到指定的输出流中去。 下面的程序使用FileInputStream来执行输入，并使用FileOutPutStream来输出123456789101112131415161718import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamTest { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); FileOutputStream fos = new FileOutputStream(\"newfile.txt\")){ byte[] bbuf = new byte[32]; int hasRead = 0; while ((hasRead=fis.read(bbuf))&gt;0){ fos.write(bbuf,0,hasRead); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 注：使用Java的IO执行输出的时候，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区的数据flush到物理节点（因为在执行close()方法之前，自动执行输出流flush()方法）。Java中很多输出流默认都提供了缓存功能，无需刻意记忆哪些流有缓冲功能、哪些没有、只要正常关闭所有的输出流即可保证程序正常。 如果希望直接输出字符串内容，使用Writer效果会好一点12345678910111213import java.io.FileWriter;import java.io.IOException;public class FileWriterTest { public static void main(String[] args) { try(FileWriter fw = new FileWriter(\"poem.txt\")){ fw.write(\"锦瑟\"); fw.write(\"锦瑟无端五十弦，一弦一柱思华年。\\r\\n\"); fw.write(\"庄生晓梦迷蝴蝶，望帝春心托杜鹃.\\r\\n\"); }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序在输出字符串内容的时候，字符串后面是\\r\\n,这是Windows平台的换行符，通过这种方式就可以让输出内容换行，如果是Linux/Unix/BSD等平台，则使用\\n作为换行符即可 输入/输出流体系上面介绍了4个文件的节点流的使用方法，但是4个基类使用有些繁琐，简化开发，就需要使用到了处理流了。 处理流的用法处理流可以隐藏底层设备上的节点流的差异，并对外提供更加方便的输入/输出方法。使用处理流思路是，使用处理流来保证节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的I/O设备，文件交互。实际识别处理流十分简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流；而所有节点流都是直接以物理IO节点作为构造器参数的。 使用处理流的优势1.对于开发人员来说，使用处理流进行输入/输出操作更加简单。2.使用处理流的执行效率更高 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class PrintStreamTest { public static void main(String[] args) { try( FileOutputStream fos = new FileOutputStream(\"text.txt\"); PrintStream ps = new PrintStream(fos); ){ //使用PrintStream执行输出 ps.println(\"普通字符\"); //直接使用PrintStream输出对象 ps.println(new PrintStreamTest()); } catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中定义了一个节点输出流FileOutputStream, 然后程序使用PrintStream包装了该节点输出流，最后使用PrintStream输出字符串、输出对象..PrintStream的输出功能非常强大，标准输出System.out的类型就是PrintStream。在使用处理流包装了底层节点流之后，关闭输入/输出流资源时，只要关闭最上层的处理流即可。关闭最上层的处理流时，系统会自动关闭被该处理流包装的节点流。 输入/输出体系java的输入输出体系提供了接近40个类，之所以如此复杂是因为实现更好的设计，把IO流按功能分成了很多的类，而每个类有分别提供了字节流和字符流，字节流字符流又分为输入流输出流两大类。 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream FilterOutPutStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInptStream DataOutputStream 通常来说，字节流的功能比字符流的功能强大的多，因为计算机中数据大多数是二进制文件。问题是如果使用字节流来处理文本，则需要使用合适的方式把字节字节转换为字符，会增加编程的难度。所以通常有一个规则：如果进行输入/输出的内容是文本内容，则应该考虑使用字符流；如果进行输入/输出的内容是二进制内容，就应该考虑使用字节流 上面的表中还列出了以数组为物理节点的字节流，字节流以字节数组为节点，字符流以字符数组为节点；这种数组为物理节点的节点流消除了创建节点流对象时，需要传入应该字节数组或者字符数组之外，用法上与文件节点流完全相似。字符流还可以使用字符串作为物理节点，用于实现从字符串读取内容，或将内容写入字符串（StringBuffer充当字符串），下面程序示范了使用字符串作为物理节点的字符输入/输出流的用法 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;public class StringNodeTest { public static void main(String[] args) { String src = \"从明天起，做一个幸福的人\\n\" + \"喂马劈柴，周游世界\\n\" + \"从明天起，关心粮食和蔬菜\\n\" + \"我有一所房子，面朝大海，春暖花开\\n\"; char[] buff = new char[32]; int hasRead = 0; try ( StringReader sr = new StringReader(src)) { while ((hasRead = sr.read(buff)) &gt; 0) { System.out.println(new String(buff, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } try ( //创建StringWriter时，实际上以一个StringBuffer作为输出节点 //下面就是指定的20就是StringBuffer的初始长度 StringWriter sw = new StringWriter() ) { sw.write(\"有一个美丽的世界\"); sw.write(\"她在远方等我\"); sw.write(\"那里有天真的孩子\"); sw.write(\"还有姑娘的酒窝\"); System.out.println(\"------下面是sw字符串节点里的内容-----\"); System.out.println(sw.toString()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序与前面使用FileReader和FileWriter的程序基本相似，只是在创建StringReader和StringWriter对象时传入的是字符串节点，而不是文件节点。由于String是不可变的字符串对象，所以StringWriter使用StringBuffer作为输出节点。 转换流输入/输出流体系中还提供了两个转换流，这两个转换流用于实现将字节流转换成字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter 将字节输出流转换成字符输出流。 问：为什么没有把字符流转换为字节流的转换流？ 想一想字符流和字节流的差别:字节流比字符流的使用范围更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢?反之，如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以Java只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。 12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class KeyinTest { public static void main(String[] args) { try ( //将System.in对象转换为Reader对象 InputStreamReader reader = new InputStreamReader(System.in); //将普通的Reader包装成BufferedReader BufferedReader br = new BufferedReader(reader) ) { String line = null; //采取循环的方式来读取 while ((line = br.readLine()) != null) { //如果读取字符串是exit，则程序退出 if (line.equals(\"exit\")) { System.exit(1); } //打印读取内容 System.out.println(\"输入内容：\" + line); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中 的粗体字代码负责将System.in包装成BufferedReader, BufferedReader流具有缓冲功能，它可以一次读取一行文本——一以换行符为标志， 如果它没有读到换行符，则程序阻塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时,只有按下回车键,程序才会打印出刚刚输入的内容。由于BufferedReader具有一个readLine()方法，可以非常方便地一次读入一行内容，所以经常把读取文本内容的输入流包装成BufferedReader,用来方便地读取输入流的文本内容。 推回输入流在输入/输出流体系中，有两个特殊的流与众不同，就是PushbackInputStream和PushbackReader,它们都提供了如下三个方法。 void unread(byte[]/char[]bu):将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(byte[]/char[] b, int off, int len);将一个字 节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(intb):将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区里，而推回输入流每次调用read()方法时总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流中读取。当程序创建一个PushbackInputStream和PushbackReader时需要指定推回缓冲区的大小，默认的推回缓冲区的长度为1。如果程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileReader;import java.io.IOException;import java.io.PushbackReader;public class PushbackTest { public static void main(String[] args) { try ( //创建一个PushbackReader对象，指定推回缓冲区的长度为64 PushbackReader pr = new PushbackReader(new FileReader(\"./IO/src/PushbackTest.java\"), 64); ) { char[] buff = new char[32]; // 用以保存上次读取的字符串内容 String lastContent = \"\"; int hasRead = 0; //循环读取文件 while ((hasRead = pr.read(buff)) &gt; 0) { //将读取的内容转换为字符串 String content = new String(buff, 0, hasRead); int targetIndex = 0; //将上次读取的字符串和本次读取的字符串拼接起来 if ((targetIndex = (lastContent + content).indexOf(\"new PushbackReader\")) &gt; 0) { //将本次内容和上次内容一起推回缓冲区 pr.unread((lastContent + content).toCharArray()); //重新定义一个长度为targetIndex的char数组 if (targetIndex &gt; 32) { buff = new char[targetIndex]; } //再次读取指定长度的内容（就是目标字符串之前的内容） pr.read(buff, 0, targetIndex); //打印读取的内容 System.out.println(new String(buff, 0, targetIndex)); System.exit(0); } else { //打印上次读取的内容 System.out.println(lastContent); //将本次内容设为上次读取的内容 lastContent = content; } } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的粗体字代码实现了将指定内容推回到到推回缓冲区，于是当程序再次调用read方法时，实际上只读取了推回缓冲区的部分内容，从而实现了只打印目标字符串前面的内容 重定向标准输入/输出Java 的标准输入/输出分别通过System.in和System.out来代表，在默认情况下它们分别代表键盘和显示器，程序通过System.in来获取输入时，实际上是从键盘读取输入;当程序试图通过Syste m.out执行输出时，程序总是输出到屏幕。 在System类里提供了如下三个重定向标准输入/输出的方法。 static void setErr(PrintStreamer):重定向“标准”错误输出流。 static void setIn(InputStream in):重定向“标准”输入流。 static void setOut(PrintStream out):重定向“标准”输出流。 下面程序通过重定向标准输出流，将System.out的输出重定向到文件输出，而不是在屏幕上输出。 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class RedirectOut { public static void main(String[] args) { try ( //一次性创建printStream输出流 PrintStream ps = new PrintStream(new FileOutputStream(\"out.txt\")) ) { //将标准流定向到ps System.setOut(ps); System.out.println(\"普通字符串\"); //向标准输出一个对象 System.out.println(new RedirectOut()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 下面程序采用重定向标准输入，从而可以将System.in重定向到指定文件，而不是键盘输入。123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.IOException;import java.util.Scanner;public class RedirectIn { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/RedirectIn.java\") ){ System.setIn(fis); //使用System.in创建Scanner对象，用于获取标准输入 Scanner sc = new Scanner(System.in); //增加下面一行只把回车作为分隔符 sc.useDelimiter(\"\\n\"); //判断下面一行是否还有输出项目 while (sc.hasNext()){ //输入输出项 System.out.println(\"键盘输入的内容是\"+sc.next()); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中的粗体字代码创建了一个FileInputStream输入流,并使用System的setln()方法将系统标准输入重定向到该文件输入流。运行上面程序，程序不会等待用户输入，而是直接输出了Redireetnjava文件的内容，这表明程序不再使用键盘作为标准输入，而是使用Redirectln.java文件作为标准输入源。 Java虚拟机读写其他进程的数据使用Runtime对象的exec()方法可以运行平台上的其他程序，该法产生一个Process对象，Process对象代表由该Java程序启动的子进程。Process 类提供了如下三个方法，用于让程序和其子进程进行通信。 InputStream getErrorStream():获取子进程的错误流。 InputStream getlnputStream():获取子进程的输入流。 InputStream getOutputStream():获取子进程的输出流。 如果试图让子程序读取程序中的数据，那么应该使用的是输出流。因为站在Java程序的角度来看，子进程读取Java程序的数据，就是让Java程序吧数据输出到子程序中（就像把数据输出到文件中一样，只是现在由子进程代替了文件节点），所以应该使用输出流。 RandomAccessFileRandomAccessFile是Java输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是，只需要访问文件部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。 与OutputStream、 Writer等输出流不同的是，RandomAccessFile 允许自由定位文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile. RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他10节点。 RandomAccessFile对象也包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件记录指针位于文件头(也就是0处)，当读/写了n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由移动该记录指针,既可以向前移动，也可以向后移动。RandomAccessFile 包含了如下两个方法来操作文件记录指针。 long getFilePointer):返回文件记录指针的当前位置。 void seek(long pos):将文件记录指针定位到pos位置。 RandomAccessFile既可以读文件，也可以写，所以它既包含了完全类似于InputStream的三个read()方法,其用法和InputStream的三个read()方法完全一样;也包含了完全类似于OutputStream的三个write()方法，其用法和OutputStream的三个write()方法完全一样。 除此之外，RandomAccessFile 还包含了一系列的readXxx()和writeXxx()方法来完成输入、输出。 RandomAccessFile类有两个构造器,其实这两个构造器基本相同,只是指定文件的形式不同而已一个使用String参数来指定文件名,一个使用File 参数来指定文件本身。除此之外,创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，该参数有如下4个值。 “r”: 以只读方式打开指定文件。如果试图对该RandomAccessFile 执行写入方法，都将抛出IOException异常。 “rw”: 以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。 “rws”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 “rwd”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。下面程序使用了RandomAccessFile来访问指定的中间部分数据。1234567891011121314151617181920212223import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileTest { public static void main(String[] args) { try ( RandomAccessFile raf = new RandomAccessFile(\"./IO/src/RandomAccessFileTest.java\", \"r\") ) { //获取RandomAccessFile对象文件指针的位置，初始位置为0 System.out.println(\"RandomAccessFile的文件指针的初始位置\" + raf.getFilePointer()); //移动raf的文件记录指针的位置 raf.seek(300); byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = raf.read(bbuf)) &gt; 0) { System.out.println(new String(bbuf, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的代码创建了一个RandomAccessFile对象，该对象以只读方式打开了RandomAccessFileTest.java文件,这意味着该RandomAccessFile对象只能读取文件内容,不能执行写入。程序中第二行粗体字代码将文件记录指针定位到300处，也就是说，程序将从300字节处开始读、写，程序接下来的部分与使用InputStream读取并没有太大的区别。运行上面程序，将看到程序只读取后面部分的效果。 下面程序示范了如何向指定文件后追加内容，为了追加内容,程序应该先将记录指针移动到文件最后，然后开始向文件中输出内容。12345678910111213141516import java.io.IOException;import java.io.RandomAccessFile;public class AppendContent { public static void main(String[] args) { try ( //1.以读写方式打开一个RandomAccessFile对象 RandomAccessFile raf = new RandomAccessFile(\"out.txt\", \"rw\"); ) { raf.seek(raf.length()); raf.write(\"追加的内容！\\r\\n\".getBytes()); } catch (IOException ioe) { ioe.printStackTrace(); } }} RandomAccessFile依然不能向文件的指定位置插入内容,如果直接将文件记录指针移动到中间某位置后开始输出，则新输出的内容会覆盖文件中原有的内容。如果需要向指定位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等把需要插入的数据写入文件后，再将缓冲区的内容追加到文件后面。 12345678910111213141516171819202122232425262728293031323334353637import java.io.*;public class InsertContext { public static void insert(String fileName, long pos, String insertContext) throws IOException { File tmp = File.createTempFile(\"tmp\", null); tmp.deleteOnExit(); try ( RandomAccessFile raf = new RandomAccessFile(fileName, \"rw\"); //使用临时文件来保存插入点后的数据 FileOutputStream tmpOut = new FileOutputStream(tmp); FileInputStream tmpIn = new FileInputStream(tmp); ) { raf.seek(pos); //-------下面代码将插入点之后的内容读入临时文件中保存 byte[] bbuf = new byte[64]; //用于保存实际读取的字节数 int hasRead = 0; //循环读取插入点后的数据 while ((hasRead=raf.read(bbuf))&gt;0){ tmpOut.write(bbuf,0,hasRead); } //下面代码用于插入 raf.seek(pos); raf.write(insertContext.getBytes()); //追加临时文件的内容 while((hasRead=tmpIn.read(bbuf))&gt;0){ raf.write(bbuf,0,hasRead); } } catch (IOException ioe) { ioe.printStackTrace(); } } public static void main(String[] args)throws IOException { insert(\"./IO/src/InsertContent.java\",45,\"插入的内容\\r\\n\"); }} 上面程序中 使用File的createTempFile(String prefix, String suffix)方法创建了一个临时文件(该临时文件将在JVM退出时被删除),用以保存被插入文件的插入点后面的内容。程序先将文件中插入点后的内容读入临时文件中,然后重新定位到插入点，将需要插入的内容添加到文件后面,最后将临时文件的内容添加到文件后面，通过这个过程就可以向指定文件、指定位置插入内容。每次运行上面程序，都会看到向InsertContentjava中插入了一行字符串。 多线程断点的网络下载工具(如FlashGet等)就可通过RandomAccessFile类来实现，所有的下载工具在下载开始时都会建立两个文件:一个是与被下载文件大小相同的空文件，一个是记录文件指针的位置文件，下载工具用多条线程启动输入流来读取网络数据, 并使用RandomAccessFile将从网络上读取的数据写入前面建立的空文件中，每写一些数据后，记录文件指针的文件就分别记下每个RandomAccessFile当前的文件指针位置一网络断开后，再次开始下载时，每个RandomAccessFile都根据记录文件指针的文件中记录的位置继续向下写数据。","link":"/2019/01/23/Java IO/"},{"title":"MySQL基础","text":"关系型数据库基本概念严格来说，数据库(Database)仅仅是存放用户数据的地方。当用户访问、操作数据库中的数据时，就需要数据库管理系统的帮助。数据库管理系统的全称是Database Management System,简称DBMS。习惯上常常把数据库和数据库管理系统笼统地称为数据库,通常所说的数据库既包括存储用户数据的部分，也包括管理数据库的管理系统。 DBMS是所有数据的知识库，它负责管理数据的存储、安全、一致性、并发、恢复和访问等操作。DBMS有一个数据字典(有时也被称为系统表)，用于存储它拥有的每个事务的相关信息，例如名字、结构、位置和类型，这种关于数据的数据也被称为元数据(metadata)。在数据库发展历史中，按时间顺序主要出现了如下几种类型的数据库系统。 网状型数据库 层次型数据库 关系数据库 面向对象数据库 在上面4种数据库系统中，关系数据库是理论最成熟、应用最广泛的数据库。从20世纪70年代末开始，关系数据库理论逐渐成熟，随之涌现出大量商用的关系数据库。关系数据库理论经过30多年的发展已经相当完善，在大量数据的查找、排序操作.上非常成熟且快速,并对数据库系统的并发、隔离有非常完善的解决方案。 面向对象数据库则是由面向对象编程语言催生的新型数据库，目前有些数据库系统如Oracle11g等开始增加面向对象特性，但面向对象数据库还没有大规模地商业应用。 对于关系数据库而言,最基本的数据存储单元就是数据表，因此可以简单地把数据库想象成大量数据表的集合(当然，数据库绝不仅由数据表组成)。 数据表是存储数据的逻辑单元，可以把数据表想象成由行和列组成的表格,其中每一行也被称为一条记录，每一列也被称为一个字段。为数据库建表时，通常需要指定该表包含多少列，每列的数据类型信息,无须指定该数据表包含多少行一因为 数据库表的行是动态改变的,每行用于保存一条用户数据。除此之外，还应该为每个数据表指定一个特殊列，该特殊列的值可以唯一地标识此行的记录，则该特殊列被称为主键列。 MySQL基本命令MySQL数据库的一个实例(Server Instance)可以同时包含多个数据库，MySQL 使用如下命令来查看当前实例下包含多少个数据库: show database; MySQL默认以分号作为每条命令的结束符，所以在每条MySQL命令结束后都应该输一个英文分号(;). 如果用户需要创建新的数据库，则可以使用如下命令:create database [IF NOT EXISTS] 数据库名; 如果用户需要删除指定数据库，则可以使用如下命令:drop database 数据库名; 建立了数据库之后，如果想操作该数据库(例如为该数据库建表，在该数据库中执行查询等操作),则需要进入该数据库。进入指定数据库可以使用如下命令:use 数据库名; 进入指定数据库后，如果需要查询该数据库下包含多少个数据表，则可以使用如下命令:show tables; 如果想查看指定数据表的表结构(查看该表有多少列，每列的数据类型等信息)，则可以使用如下命令:desc表名 MySQL基本登录命令mysql -P 密码 -u 用户名 -h 主机名 --default-character-set=utf8 MySQL数据库通常支持如下两种存储机制。 MyISAM:这是MySQL早期默认的存储机制，对事务支持不够好。 InnoDB: InnoDB 提供事务安全的存储机制。InnoDB 通过建立行级锁来保证事务完整性，并以Oracle风格的共享锁来处理Select语句。系统默认启动InnoDB存储机制,如果不想使用InnoDB表，则可以使用skip-innodb选项。 对比两种存储机制，不难发现InnoDB比MyISAM多了事务支持的功能，而事务支持是Java EE最重要的特性，因此通常推荐使用InnoDB存储机制。如果使用5.0以上版本的MySQL数据库系统,通常无须指定数据表的存储机制，因为系统默认使用InnoDB存储机制。如果需要在建表时显式指定存储机制，则可在标准建表语法的后面添加下面任意一句。 ENGINE=MyISAM 强制使用MyISAM存储机制。 ENGINE=InnoDB 强制使用InnoDB存储机制。 SQL语句基础SQL的全称是Structured Query Language,也就是结构化查询语言。SQL是操作和检索关系数据库的标准语言，标准的SQL语句可用于操作任何关系数据库。 使用SQL语句，程序员和数据库管理员(DBA) 可以完成如下任务。 在数据库中检索信息。 对数据库的信息进行更新。 改变数据库的结构。 更改系统的安全设置。 增加或回收用户对数据库、表的许可权限。 在上面5个任务中，一般程序员可以管理前3个任务，后面2个任务通常由DBA来完成。 标准的SQL语句通常可分为如下几种类型。 查询语句:主要由select关键字完成，查询语句是SQL语句中最复杂、功能最丰富的语句。 DML(Data Manipulation Language,数据操作语言)语句:主要由insert、update 和delete三个关键字完成。 DDL(Data Definition Language, 数据定义语言)语句:主要由create、alter、 drop 和truncate四个关键字完成。 DCL(Data Control Language,数据控制语言)语句:主要由grant和revoke两个关键字完成。 事务控制语句:主要由commit、rollback 和savepoint三个关键字完成。 SQL语句的关键字不区分大小写，也就是说，create和CREATE的作用完全一样。 在上面5种SQL语句中，DCL语句用于为数据库用户授权，或者回收指定用户的权限，通常无须程序员操作 在SQL命令中也可能需要使用标识符，标识符可用于定义表名、列名，也可用于定义变量等。这些标识符的命名规则如下。 标识符通常必须以字母开头。 标识符包括字母、数字和三个特殊字符(#_ $)。 不要使用当前数据库系统的关键字、保留字，通常建议使用多个单词连缀而成，单词之间以_分隔。 同一个模式下的对象不应该同名，这里的模式指的是外模式。 truncate是一个特殊的DDL语句，truncate 在很多数据库中都被归类为DDL，它相当于先删除指定的数据表,然后再重建该数据表。如果使用MySQL的普通存储机制, truncate确实是这样的。但如果使用InnoDB存储机制,则比较复杂,在MySQL5.0.3之前, truncate和delete完全一样;在5.0.3之后，truncate table比delete效率高，但如果该表被外键约束所参照，则依然被映射成delete操作。当使用快速truncate时，该操作会重设自动增长计数器。在5.0.13之后，快速truncate总是可用，即比delete性能要好。 DDL语句DDL语句是操作数据库对象的语句，包括创建(create)、删除(drop)和修改(alter) 数据库对象。最基本的数据库对象是数据表，数据表是存储数据的逻辑单元。但数据库里绝不仅包括数据表，数据库里可包含如表所示的几种常见的数据库对象。 对象名称 对应关键字 描述 表 table 表是存储数据的逻辑单元，以行和列的形式存在;列就是字段，行就是记录 数据字典 就是系统表，存放数据库相关信息的表。系统表里的数据通常由数据库系统护，程序员通常不应该手动删除修改系统表数据 约束 constraint 执行数据校验的规则，用于保证数据完整性的规则 视图 view 一个或者多个数据表里数据的逻辑显示。视图并不存储数据 索引 index 用于提高查询性能，相当于书的目录 函数 function 用于完成一次特定的计算，具有一个返回值 存储过程 procedure 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境 触发器 trigger 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理 创建表的语法12345create table [模式名.]表名(#可以有多个列定义columnName1 datatype [default expr])) 下表为MySQL支持的数据类型 列类型 说明 tinyint/smallint/mediumint/int(integer)/bigint 1字节/2字节/3字节/4字节/8字节整数，又可分为有符号和无符号两种。这些整数类型的区别仅仅是表数范围不同 float/double 单精度、双精度浮点类型 decimal(dec) 精确小数类型，相对于float和double不会产生精度丟失的问题 date 日期类型,不能保存时间。把java.util.Date对象保存进date列时，时间部分将会丢失 time 时间类型,不能保存日期。把java util.Date对象保存进time列时，日期部分将会丢失 datetime 日期、时间类型 timestamp 时间截类型 year 年类型，仅仅保存时间的年份 char 定长字符串类型 varchar 可变长度字符串类型 binary 定长二进制字符串类型，它以二进制形式保存字符串 varbinary 可变长度的二进制字符串类型，它以二进制形式保存字符串 tinyblob/blob/mediumblob/longblob 1字节/2字节/3字节/4字节的二进制大对象,可用于存储图片、音乐等二进制数据，分别可存储: 255B/64KB/6MB/4GB 的大小 tinytext/text/mediumtex/longtext 1字节2字节/3字节/4字节的文本对象，可用于存储超长长度的字符串，分别可存储: 255B/64KB/16MB/4GB大小的文本 enum(‘valuel’,valu2…) 枚举类型，该列的值只能是enum后括号里多个值的其中之一 set(‘valuel’,’value2’…) 集合类型，该列的值可以是set后括号里多个值的其中几个 一例：12345678CREATE TABLE `test_first` (`test_id` int(11) DEFAULT NULL,`test_price` decimal(10,0) DEFAULT NULL,`test_name` varchar(255) DEFAULT 'xxxx',`test_desc` text,`test_img` blob,`test_date` datetime DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 上面是比较常见的建表语句，这种建表语句只是创建一个空表,该表里没有任何数据。如果使用子查询建表语句，则可以在建表的同时插入数据。子查询建表语句的语法如下:12create table [模式名.]表名 [column[,column...]]as subquery; 上面语法中新表的字段列表必须与子查询中的字段列表数量匹配，创建新表时的字段列表可以省略，如果省略了该字段列表，则新表的列名与选择结果完全相同。下面语句使用子查询来建表。1234# 创建hehe数据表，该数据表和user_ inf完全相同，数据也完全相同create table heheasselect * from user_ inf; 修改变结构语法修改表结构使用alter table,修改表结构包括增加列定义、修改列定义、删除列、重命名列等操作。增加列定义的语法如下:123456alter table 表名add#可以有多个列定义column name_l datatype [default expr]，......); 一例：123456789# 为hehe数据表增加一个hehe id字段，该字段的类型为intalter table heheadd hehe_id int;#量为hehe数据表增加aaa、bbb字段，两个字段的类型都为varchar(255)alter table heheaddaaa varchar (255) default 'xxx',bbb varchar (255)); 增加字段时需要注意:如果数据表中已有数据记录，除非给新增的列指定了默认值,否则新增的数据列不可指定非空约束，因为那些已有的记录在新增列上肯定是空(实际上，修改表结构很容易失败，只要新增的约束与已有数据冲突，修改就会失败)。 修改列的语法如下12alter table 表名modify column name datatype [default expr] [first|after col name ] ; 一例123456#将hehe表的hehe id列修改成varchar (255)类型alter table hehemodify hehe_id varchar(255);单将hehe表的bbb列修改成int类型alter table hehemodify bbb int; 虽然MySQL的一个modify命令不支持一次修改多个列定义,但其他数据库如Oracle支持一个modify命令修改多个列定义,一个modify命令修改多个列定义的语法和一个add命令增加多个列定义的语法非常相似，也需要使用圆括号把多个列定义括起来。如果需要让MySQL支持-次修改多个列定义，则可在alter table后使用多个modify命令。add新增的列名必须是原表中不存在的，而modify修改的列名必须是原表中已存在的。 如果数据表里已有数据记录，则修改列定义非常容易失败，因为有可能修改的列定义规则与原有数据记录不符合。如果修改数据列的默认值，则只会对以后的插入操作有作用，对以前已经存在的数不会有任何影响。12alter table 表名drop column name 重命名数据表的语法格式如下:12alter table 表名rename to 新表名 MySQL为alter table提供了change 选项，该选项可以改变列名。change 选项的语法如下:12alter table 表名change o1d column name new_ column name type [default exprl [firstlafter col name] 对比change和modify两个选项,不难发现: change选项比modify选项多了一个列名，因为change选项可以改变列名，所以它需要两个列名。一般而言，如果不需要改变列名，使用alter table的modify选项即可，只有当需要修改列名时才会使用change选项。如下语句所示:123#将wawa数据表的bbb字段重命名为dddalter table wawachange bbb ddd int; 删除表的语法删除表的语法比较简单1drop table 表名 删除数据表的效果如下： 表结构被删除,表对象不再存在。 表里的所有数据也被删除。 该表所有相关的索引、约束也被删除 truncate 表对于大部分数据库而言,truncate都被当成DDL处理,truncate被称为“截断”某个表。它的作用是删除该表里的全部数据,但保留表结构。相对于DML里的delete命令而言, truncate的速度要快得多,而且truncate不像delete可以删除指定的记录, truncate只能一次性删除整个表的全部记录。truncate命令的语法如下:1truncate 表名 MySQL对truncate的处理比较特殊————如果使用非InnoDB存储机制, truncate比delete速度要快;如果使用 InnoDB存储机制,在 MySQL5.0.3之前,truncate和delete完全一样,在5.0.3之后, truncate table比delete效率高,但如果该表被外键约束所参照, truncate又变为delete操作。在5.0.13之后,快速truncate总是可用,即比delete性能要好。 数据库约束前面创建的数据表仅仅指定了一些列定义,这仅仅是数据表的基本功能。除此之外,所有的关系数据库都支持对数据表使用约束,通过约束可以更好地保证数据表里数据的完整性。约束是在表上强制执行的数据校验规则,约束主要用于保证数据库里数据的完整性。除此之外,当表中数据存在相互依赖性时,可以保护相关的数据不被删除。 大部分数据库支持下面5种完整性约束。 NOT NULL:非空约束,指定某列不能为空。 UNIQUE:唯一约束,指定某列或者几列组合不能重复。 PRIMARY KEY:主键,指定该列的值可以唯一地标识该条记录。 FOREIGN KEY:外键,指定该行记录从属于主表中的一条记录,主要用于保证参照完整性。 CHECK:检查,指定一个布尔表达式,用于指定对应列的值必须满足该表达式 虽然大部分数据库都支持上面5种约束,但MySQL不支持CHECK约束,虽然MySQL的SOL语句也可以使用CHECK约束,但这个CHECK约束不会有任何作用。 虽然约束的作用只是用于保证数据表里数据的完整性,但约束也是数据库对象,并被存储在系统表中,也拥有自己的名字。根据约束对数据列的限制,约束分为如下两类: 单列约束:每个约束只约束一列。 多列约束:每个约束可以约束多个数据列。 为数据表指定约束有如下两个时机。 建表的同时为相应的数据列指定约束。 建表后创建,以修改表的方式来增加约束。 大部分约束都可以采用列级约束语法或者表级约束语法。下面依次介绍5种约束的建立和删除(约束通常无法修改)。 MySQL使用information schema数据库里的TABLE CONSTRAINTS表来保存该数据库实例中所有的约束信息,用户可以通过查询TABLE_CONSTRAINTS表来获取该数据库的约束信息。 NOT NULL约束非空约束用于确保指定列不允许为空，非空约束是比较特殊的约束，它只能作为列级约束使用，只能使用列级约束语法定义。这里要介绍一下SQL中的null值，SQL中的null不区分大小写。SQL中的null具有如下特征。 所有数据类型的值都可以是null, 包括int、 float、boolean等数据类型。 与Java类似的是，空字符串不等于null, 0也不等于null。如果需要在建表时为指定列指定非空约束，只要在列定义后增加not null即可。 建表语句如下:123456789create table hehe(#建立了非空约束，这意味着hehe_id不可以为nullhehe id int not null,# MySQL的非空约束不能指定名字hehe name varchar (255) default 'xyz' not nul1 ,#下面列可以为空，默认就是可以为空hehe gender varchar (2) nul1); 除此之外，也可以在使用alter table修改表时增加或者删除非空约束，SQL 命令如下:123456789#增加非空约束alter table hehemodify hehe gender varchar (2) not null#取消非空约束alter table hehemodify hehe name varchar(2) null;#取消非空约束，并指定默认值alter table hehemodify hehe name varchar (255) default ‘abc' null; UNIQUE约束唯一约束用于保证指定列或指定列组合不允许出现重复值。虽然唯一约束的列不可以出现重复值，但可以出现多个null值(因为在数据库中null不等于null)。 同一个表内可建多个唯一约束， 唯一约束也可由多列组合而成。当为某列创建唯一约束时, MySQL会为该列相应地创建唯一索引。 如果不给唯一约束起名，该唯一约束默认与列名相同。 唯一约束既可以使用列级约束语法建立,也可以使用表级约束语法建立。如果需要为多列建组合约束，或者需要为唯一约束指定约束名，则只能用表级约束语法。 当建立唯一约束时，MySQL 在唯一约束所在列或列组合上建立对应的唯一索引。 使用列级约束语法建立唯一约束非常简单，只要简单地在列定义后增加unique关键字即可。SQL语句如下: 12345678#建表时创建唯一约束，使用列级约束语法建立约束create table unique_test(#建立了非空约束，这意味着test_id不可以为nulltest_id int not null, #unique就是唯一约束，使用列级约束语法建立唯一约束test_name varchar (255) unique); 如果需要为多列组合建立唯一约束,或者想自行指定约束名，则需要使用表级约束语法。1[constraint 约束名]约束定义 上面的表级约束语法格式既可放在create table语句中与列定义并列，也可放在alter table语句中使用add关键字来添加约束。123456789101112#建表时创建唯约束，使用表级约束语法建立约束create table unique_test2(#建立了非空约束，这意味着test_id不可以为nulltest_id int not null,test_name varchar (255) ,test_pass varchar (255) ,#使用表级约束语法建立唯一约束unique (test_name)，#使用表级约束语法建立唯一约束，而且指定约束名constraint test2_uk unique(test_pass)); 上面的建表语句为test_name、test_pass 分别建立了唯一约束， 这意味着这两列都不能出现重复值。除此之外，还可以为这两列组合建立唯一约束。12345678910#建表时创建唯一约束，使用表级约束语法建立约束create table unique_test3(#建立了非空约束，这意味着test_id不可以为nulltest_id int not null,test_name varchar (255) ,test_pass varchar (255)，#使用表级约束语法建立唯一约束，指定两列组合不允许重复constraint test3_uk unique(test_name,test_pass)); 对于上面的unique_test2 和unique_test3两个表,都是对test_ name、test_pass建立唯一约束，其中unique_test2要求test_ name、test_pass都不能出现重复值，而unique_test3只要求test_name、test_pass两列值的组合不能重复。 也可以在修改表结构时使用add关键字来增加唯一约束123#增加唯一约束alter table unique_test3add unique (test_name, test_pass) ; 还可以在修改表时使用modify关键字，为单列采用列级约束语法来增加唯一约束:123#为unique_test3表的test_name列增加唯约束alter table unique_test3modify test name varchar(255) unique; 对于大部分数据库而言,删除约束都是在alter table语句后使用drop constraint约束名语法来完成的，但MySQL并不使用这种方式，而是使用“drop index约束名”的方式来删除约束。例如如下SQL语句:123#删除unique_test3表上的test3_uk唯约束alter table unique_test3drop index test3_uk; PRIMARY KEY约束主键约束相当于非空约束和唯一约束， 即主键约束的列既不允许出现重复值，也不允许出现null值;如果对多列组合建立主键约束,则多列里包含的每一列都不能为空，但只要求这些列组合不能重复。主键列的值可用于唯一地标识表中的一条记录。 每一个表中最多允许有一个主键,但这个主键约束可由多个数据列组合而成，主键是表中能唯一确定一行记录的字段或字段组合。 建立主键约束时既可使用列级约束语法，也可使用表级约束语法。如果需要对多个字段建立组合主键约束，则只能使用表级约束语法。使用表级约束语法来建立约束时，可以为该约束指定约束名。但不管用户是否为该主键约束指定约束名，MySQL总是将所有的主键约束命名为PRIMARY。 建表时创建主键约束，使用列级约束语法:123456create table primary_ test(#建立了主键约束test id int primary key,test_ name varchar (255)); 建表时创建主键约束，使用表级约束语法:12345678create table primary_test2(test_id int not null,test_name varchar (255) ,test_pass varchar (255) ,#井指定主键约束名为test2_pk,对大部分数据库有效,但对MySQL无效 #MySQL数据库中该主键约束名依然是PRIMARYconstraint test2_pk primary key(test_id) ); 建表时创建主键约束，以多列建立组合主键，只能使用表级约束语法:1234567create table primary_test3（test_name varchar (255)，test_pass varchar (255) ,并建立多列组合的主键约束primary key(test_name, test_pass)); 如果需要删除指定表的主键约束,则在alter table 语句后使用drop primary key子句即可。SQL语如下:123#删除主键约束alter table primary test3drop primary key; 如果需要为指定表增加主键约束，既可通过modify修改列定义来增加主键约束，这将采用列级约束语法来增加主键约束;也可通过add来增加主键约束，这将采用表级约束语法来增加主键约束。SQL语句如下:普使用表级约束语法增加主键约束12alter table primary_test3add primary key(test_name, test_pass); 如果只是为单独的数据列增加主键约束,则可使用modify修改列定义来实现:123#使用列级约束语法增加主键约束alter table primary test3modify test name varchar (255) primary key; 不要连续执行上面两条SQL语句，因为上面两条SQL语句都是为primary_test3增加主键约束，而同一个表里最多只能有一个主键约束，所以连续执行上面两条SQL语句肯定出现错误。为了避免这个问题，可以在成功执行了第一条增加主键约束的SQL语句之后，先将primary_test3里的主键约束删除后再执行第二条增加主键约束的SQL语句。 很多数据库对主键列都支持一种自增长的特性,如果某个数据列的类型是整型,而且该列作为主键列，则可指定该列具有自增长功能。指定自增长功能通常用于设置逻辑主键列,该列的值没有任何物理意义，仅仅用于标识每行记录。MySQL使用auto_increment来设置自增长.123456create table primary_test4#建立主键约束，使用自增长test_id int auto_increment primary key,test_name varchar (255)，test_pass varchar (255)); 一旦指定了某列具有自增长特性，则向该表插入记录时可不为该列指定值,该列的值由数据库系统自动生成。 FOREIGN KEY 约束外键约束主要用于保证一个或两个数据表之间的参照完整性,外键是构建于一个表的两个字段或者两个表的两个字段之间的参照关系。外键确保了相关的两个字段的参照关系:子(从)表外键列的值必须在主表被参照列的值范围之内，或者为空(也可以通过非空约束来约束外键列不允许为空)。 当主表的记录被从表记录参照时，主表记录不允许被删除，必须先把从表里参照该记录的所有记录全部删除后，才可以删除主表的该记录。还有一种方式,删除主表记录时级联删除从表中所有参照该记录的从表记录。 从表外键参照的只能是主表主键列或者唯一键列,这样才可保证从表记录可以准确定位到被参照的主表记录。同一个表内可以拥有多个外键。 建立外键约束时，MySQL也会为该列建立索引。 外键约束通常用于定义两个实体之间的一对多、一对一的关联关系。对于一对多的关联关系,通常在多的一端增加外键列，例如老师一学生(假设一个老师对应多个学生，但每个学生只有一个老师,这是典型的一对多的关联关系)。为了建立他们之间的关联关系，可以在学生表中增加一个外键列，该列中保存此条学生记录对应老师的主键。对于一对一的关联关系，则可选择任意一方来增加外键列,增加外键列的表被称为从表,只要为外键列增加唯一约束就可表示一对一的关联关系了。对于多对多的关联关系，则需要额外增加一个连接表来记录它们的关联关系。 建立外键约束同样可以采用列级约束语法和表级约束语法。如果仅对单独的数据列建立外键约束，则使用列级约束语法即可;如果需要对多列组合创建外键约束，或者需要为外键约束指定名字,则必须使用表级约束语法。 采用列级约束语法建立外键约束直接使用references关键字, references 指定该列参照哪个主表，以及参照主表的哪一列。1234567891011121314#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table(#auto_increment: 代表数据库的自动编号策略，通常用作数据表的 逻辑主键teacher_id int auto_increment,teacher_name varchar(255),primary_key(teacher_id));create table student_table(#为本表建立主键约束student_id int auto_increment primary key,student_name varchar(255)，#指定java_teacher参照到teacher_table的teacher_id列java_teacher int references teacher_table (teacher id)); 值得指出的是，虽然MySQL支持使用列级约束语法来建立外键约束,但这种列级约束语法建立的外键约束不会生效，MySQL提供这种列级约束语法仅仅是为了和标准SQL保持良好的兼容性。因此，如果要使MySQL中的外键约束生效，则应使用表级约束语法。 12345678910111213141516#为了保证从表参照的主表存在，通常应该先建主表create table teacher_tablel(#auto_increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键teacher_id int auto_increment,teacher_name varchar(255),primary key (teacher_id));create table student_table1(#为本表建立主键约束student_id int auto_increment primary key,student_name varchar (255)，#指定java_teacher参照到teacher_tablel的teacher_id列java_teacher int,foreign key(java_teacher) references teacher_tablel (teacher_id)); 如果使用表级约束语法，则需要使用foreige key来指定本表的外键列，并使用references来指定参照哪个主表，以及参照到主表的哪个数据列。使用表级约束语法可以为外键约束指定约束名,如果创建外键约束时没有指定约束名，则MySQL会为该外键约束命名为table_name_ibfk_n, 其中table_name 是从表的表名，而n是从1开始的整数。 如果需要显式指定外键约束的名字，则可使用constraint来指定名字。1234567891011121314#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table2#auto increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键teacher_id int auto_increment,teacher_name varchar(255) ,primary key (teacher_id));create table student_table2#为本表建立主键约束student_id int auto_increment primary key,student_name varchar(255)，java_teacher int,#使用表级约束语法建立外键约束，指定外键约束的约束名为student_ teacher_fkconstraint student_teacher_fk foreign key (java_teacher) references teacher_table2 (teacher_id)); 如果需要建立多列组合的外键约束，则必须使用表级约束语法，如下SQL语句所示:123456789101112131415161718#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table3(teacher_name varchar(255) ,teacher_pass varchar(255) ,#以两列建立组合主键primary key(teacher_name，teacher_pass));create table student_table3#为本表建立主键约束student_id int auto_increment primary key,student_name varchar (255) ,java_teacher_name varchar (255) ,java_teacher_pass varchar (255) ,#使用表级约束语法建立外键约束，指定两列的联合外键foreign key(java_teacher_name，java_teacher_pass)references teacher_table3 (teacher_name，teacher_pass)); 删除外键约束的语法很简单，在alter table后增加“drop foreign key约束名”子句即可。如下代码所示:12#删除student_table3表上名为student_table3_ibfk_1的外键约束alter table student table3drop foreign key student_table3_ibfk_1; 增加外键约束通常使用add foreign key命令。如下SQL语句所示:1234#修改student_table3数据表，增加外键约束alter table student_table3add foreign key(java_teacher_name，java_teacher_pass)references teacher_table3 (teacher_name，teacher_pass); 值得指出的是，外键约束不仅可以参照其他表，而且可以参照自身，这种参照自身的情况通常被称为自关联。例如，使用一个表保存某个公司的所有员工记录，员工之间有部门经理和普通员工之分，部门经理和普通员工之间存在一”对 多的关联关系，但他们都是保存在同一个数据表里的记录，这就是典型的自关联。下面的SQL语句用于建立自关联的外键约束。12345678#使用表级约束语法建立外约束键，且直接参照自身create table foreign_testforeign_id int auto increment primary key,foreign_name varchar (255)，#使用该表的refer_id参照到本表的foreign id列refer_id int,foreign key(refer_id) references foreign_test(foreign_id)); 如果想定义当删除主表记录时，从表记录也会随之删除，则需要在建立外键约束后添加on delete cascade或添加on delete set null,第-种是删除主表记录时，把参照该主表记录的从表记录全部级联删除;第二种是指定当删除主表记录时，把参照该主表记录的从表记录的外键设为null。如下SQL语句所示:1234567891011121314151617#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table4(# auto_increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键teacher_id int auto_increment,teacher_name varchar(255)，primary key(teacher_id));create table student_table4#为本表建立主键约束student_id int auto_increment primary key,student_name varchar (255)，java_teacher int,#使用表级约束语法建立外键约束，定义级联删除foreign key(java_teacher) references teacher_table4 (teacher id) on delete cascade#也可用on delete set null); CHECK 约束当前版本的MySQL支持建表时指定CHECK约束,但这个CHECK约束不会有任何作用。建立CHECK约束的语法很简单，只要在建表的列定义后增加check(逻辑表达式)即可。如下SQL语句所示:12345678create table check_testemp_id int auto_increment,emp_name varchar(255),emp_salary decimal,primary key(emp_id) ，#普建立CHECK约束check (emp_salary&gt;0)); 虽然上面的SQL语句建立的check_test表中有CHECK约束, CHECK约束要求emp_salary大于0,但这个要求实际上并不会起作用。 索引索引是存放在模式(schema)中的一个数据库对象，虽然索引总是从属于数据表，但它也和数据表一样属于数据库对象。创建索引的唯一作用就是加速对表的查询,索引通过使用快速路径访问方法来快速定位数据，从而减少了磁盘的I/O。索引作为数据库对象，在数据字典中独立存放，但不能独立存在，必须属于某个表。MySQL使用information_schema数据库里的STATISTICS表来保存该数据库实例中的所有索引信息，用户可通过查询该表来获取该数据库的索引信息。 创建索引有两种方式。 自动:当在表上定义主键约束、唯一约束和外键约束时，系统会为该数据列自动创建对应的索引。 手动:用户可以通过create index…语句来创建索引。 删除索引也有两种方式。 自动:数据表被删除时，该表上的索引自动被删除。 手动:用户可以通过drop index…语句来删除指定数据表上的指定索引。 索引的作用类似于书的目录，几乎没有一本书没有目录，因此几乎没有一个表没有索引。一个表中可以有多个索引列，每个索引都可用于加速该列的查询速度。 正如书的目录总是根据书的知识点来建立一样因为读者经常要根据知识点来查阅一本书。类似的, 通常为经常需要查询的数据列建立索引，可以在一列或者多列上创建索引。创建索引的语法格式如下:12create index index_nameon table name(column[, column]...); 下面的索引将会提高对employees表基于last_name字段的查询速度。12create index emp_last_name_idxon employees(1ast_name) ; 也可同时对多列建立索引，如下SQL语句所示:123#下面语句为employees的first_name和last_name两列同时建立索引create index emp_last_name_idx2on employees (first_name, last_name); MySQL中删除索引需要指定表，采用如下语法格式:1drop index索引名on表名 如下SQL语句删除了employees表上的emp_last_name_idx2索引:12drop index emp_last_name_idx2on employees 有些数据库删除索引时无须指定表名,因为它们要求建立索引时每个索引都有唯一的名字, 所以无须指定表名，例如Oracle就采用这种策略。但MySQL只要求同一个表内的索引不能同名，所以删除索引时必须指定表名。索引的好处是可以加速查询。但索引也有如下两个坏处。 与书的目录类似，当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销。 存储索引信息需要-一定的磁盘空间。 视图视图看上去非常像一个数据表，但它不是数据表，因为它并不能存储数据。视图只是一个或多个数据表中数据的逻辑显示。使用视图有如下几个好处。 可以限制对数据的访问。 可以使复杂的查询变得简单。 提供了数据的独立性。 提供了对相同数据的不同显示。因为视图只是数据表中数据的逻辑显示————也就是一个查询结果,所以创建视图就是建立视图名和查询语句的关联。创建视图的语法如下:123create or replace view视图名assubquery 从上面的语法可以看出，创建、修改视图都可使用上面语法。上面语法的含义是,如果该视图不存在，则创建视图;如果指定视图名的视图已经存在，则使用新视图替换原有视图。后面的subquery就是一个查询语句，这个查询可以非常复杂。通过建立视图的语法规则不难看出，所谓视图的本质，其实就是一条被命名的SQL查询语句。 一旦建立了视图以后，使用该视图与使用数据表就没有什么区别了，但通常只是查询视图数据,不会修改视图里的数据，因为视图本身没有存储数据。如下SQL语句就创建了一个简单的视图:123create or replace view view_testasselect teacher_name，teacher_pass from teacher_table; 通常不推荐直接改变视图的数据,因为视图并不存储数据,它只是相当于一条命名的查询语句而已。为了强制不允许改变视图的数据，MySQL 允许在创建视图时使用with check option 子句，使用该子句创建的视图不允许修改，如下所示:12345create or replace view view_testasselect teacher_name from teacher_table#指定不允许修改该视图的数据with check option; 大部分数据库都采用with check option来强制不允许修改视图的数据，但Oracle采用with read only来强制不允许修改视图的数据. 删除视图使用如下语句:1drop view 视图名 如下SQL语句删除了前面刚刚创建的视图:1drop view view_test; DML语句语法DML语法主要完成以下三个操作 插入新数据。 修改已有数据。 删除不需要的数据。DML语句由insert into、update 和delete from三个命令组成。 insert into语句insert into用于向指定数据表中插入记录。对于标准的SQL语句而言,每次只能插入一条记录。insert into语句的语法格式如下:12insert into table_name [(column [, column...])]values (value [，value. ..1) ; 执行插入操作时，表名后可以用括号列出所有需要插入值的列名，而values后用括号列出对应需要插入的值。 如果省略了表名后面的括号及括号里的列名列表，默认将为所有列都插入值,则需要为每一列都指定一个值。如果既不想在表名后列出列名，又不想为所有列都指定值,则可以为那些无法确定值的列分配null。下面的SQL语句示范了如何向数据表中插入记录。 在表名后使用括号列出所有需要插入值的列:12insert into teacher_table2 (teacher_name)values('xyz') ; 如果不想在表后用括号列出所有列，则需要为所有列指定值;如果某列的值不能确定，则为该列分配一个null值。123insert into teacher table2#使用null代替主键列的值values (nul1，'abc') ; 上面两条插入语句后系统表中将会有两条数据 teacher_id teacher_name 1 xyz 2 abc 根据前面介绍的外键约束规则:外键列里的值必须是被参照列里已有的值，所以向从表中插入记录之前，通常应该先向主表中插入记录，否则从表记录的外键列只能为null.现在主表teacher_table2中已有了2条记录，现在可以向从表student_table2中插入记录了.123insert into student table2#当向外键列里插值时，外键列的值必须是被参照列里己有的值values (nul1，'张三，2); 外键约束保证被参照的记录必须存在，但并不保证必须有被参照记录，即外键列可以为null. 如果想保证每条从表记录必须存在对应的主表记录，则应使用非空、外键两个约束。 在一些特别的情况下，可以使用带子查询的插入语句,带子查询的插入语句可以一次插入多条记录:123insert into student_table2(student_name)#使用子查询的值来插入select teacher_name from teacher_table2; 正如上面的SQL语句所示，带子查询的插入语句甚至不要求查询数据的源表和插入数据的目的表是同一个表，它只要求选择出来的数据列和插入目的表的数据列个数相等、数据类型匹配即可。 MySQL甚至提供了一种扩展的语法，通过这种扩展的语法也可以一次插入多条记录。MySQL允许在values后使用多个括号包含多条记录，表示多条记录的多个括号之间以英文逗号(,) 隔开。如下SQL语句所示:1234insert into teacher_table2普同时插入多个值values(null，\"Yeeku\"),(null,\"Sharfly\"); update语句update语句用于修改数据表的记录，每次可以修改多条记录，通过使用where子句限定修改哪些记录。123update table_nameset columnl= valuel[, column2 = value2] ...[WHERE condition]; 使用update语句不仅可以一次修改多条记录，也可以一次修改多列。修改多列都是通过在set关键字后使用column1=valuel,column2=valae2.来实现的，修改多列的值之间以英文逗号(,) 隔开。下面的SQL语句将会把teacher_table2表中所有记录的teacher_name列的值都改为’孙悟空’。12update teacher_table2set teacher_name = '孙悟空' ; 也可以通过添加where条件来指定只修改特定记录，如下SQL语句所示:1234#只修改teacher_id大于1的记录update teacher_table2set teacher_name = '猪八戒'where teacher_id &gt; 1; delete from 语句delete from语句用于刪除指定数据表的记录。使用delete from语句删除时不需要指定列名，因为总是整行地删除。 使用delete from语句可以一次删除多行,删除哪些行采用where子句限定,只删除满足where 条件的记录。没有where子句限定将会把表里的全部记录删除。12delete from table_name[WHERE condition] ; 如下SQL语句将会把student_table2 表中的记录全部删除:1delete from student_table2; 也可以使用where条件来限定只删除指定记录，如下SQL语句所示:12delete from teacher_table2where teacher_id &gt; 2; 当主表记录被从表记录参照时，主表记录不能被删除，只有先将从表中参照主表记录的所有记录全部删除后，才可删除主表记录。还有一种情况，定义外键约束时定义了主表记录和从表记录之间的级联删除on delete cascade, 或者使用on delete set null用于指定当主表记录被删除时，从表中参照该记录的从表记录把外键列的值设为null. 单表查询单表查询的select语句的语法格式如下:123select column1, col umn2from 数据源[where condition] 上面语法格式中的数据源可以是表、视图等。select后的列表用于确定选择哪些列，where 条件用于确定选择哪些行，只有满足where条件的记录才会被选择出来;如果没有where条件,则默认选出所有行。如果想选择出所有列，则可使用星号(*)代表所有列。12select *from teacher_table; 如果增加where条件，则只选择出符合where条件的记录。如下SQL语句将选择出student_table表中java_teacher大于3的记录的student_name列的值。123select student_namefrom student_tablewhere java_teacher &gt; 3; 当使用select语句进行查询时，还可以在select语句中使用算术运算符(+、-、*、/),从而形成算术表达式。使用算术表达式的规则如下。 对数值型数据列、变量、常量可以使用算术运算符(+、-、*、/)创建表达式; 对日期型数据列、变量、常量可以使用部分算术运算符(+、-)创建表达式，两个日期之间可以进行减法运算，日期和数值之间可以进行加、减运算; 运算符不仅可以在列和常量、变量之间进行运算，也可以在两列之间进行运算。 不论从哪个角度来看,数据列都很像一个变量，只是这个变量的值具有指定的范围一逐行计算表中的每条记录时，数据列的值依次变化。因此能使用变量的地方，基本上都可以使用数据列。 下面的select语句中使用了算术运算符。1234567#数据列实际上可当成一个变量select teacher_id + 5from teacher_table;#查询出teacher_table表中teacher_id * 3大于4的记录select *from teacher_tablewhere teacher id * 3 &gt; 4; 需要指出的是，select后的不仅可以是数据列，也可以是表达式，还可以是变量、常量等。例如，如下语句也是正确的。123#数据列实际上可当成一个变量select 3*5, 20from teacher_ table; MySQL中没有提供字符串连接运算符，即无法使用加号(+)将字符串常量、字符串变量或字符串列连接起来。MySQL使用concat函数来进行字符串连接运算。如下SQL语句所示:123#选择出teacher_name和'xx'字符串连接后的结果select concat(teacher_name ,'xx')from teacher table; 对于MySQL而言，如果在算术表达式中使用null,将会导致整个算术表达式的返回值为null;如果在字符串连接运算中出现null,将会导致连接后的结果也是null。如下SQL语句将会返回null.12select concat(teacher_name，null)from teacher_table; 对某些数据库而言，如果让字符串和null进行连接运算，它会把null当成空字符串处理。如果不希望直接使用列名作为列标题，则可以为数据列或表达式起一个别名，为数据列或表达式起别名时，别名紧跟数据列，中间以空格隔开，或者使用as关键字隔开。如下SQL语句所示:1select teacher id + 5 as MY_ID from teacher table; 为列起别名，可以改变列的标题头，用于表示计算结果的具体含义。如果列别名中使用特殊字符(例如空格)，或者需要强制大小写敏感，都可以通过为别名添加双引号来实现。如下SQL语句所示:123#可以为选出的列起别名，别名中包括单引号字符，所以把别名用双引号引起来select teacher id + 5 \"MY'id\"from teacher table ; 如果需要选择多列，并为多列起别名，则列与列之间以逗号隔开，但列和列别名之间以空格隔开。如下SQL语句所示:12select teacher_id + 5 MY_ID，teacher_name 老师名from teacher_table; 不仅可以为列或表达式起别名，也可以为表起别名，为表起别名的语法和为列或表达式起别名的语法完全一样，如下SQL语句所示:123select teacher_id + 5 MY_ID，teacher_name 老师名#为teacher table起别名tfrom teacher_table t 前面已经提到，列名可以当成变量处理，所以运算符也可以在多列之间进行运算，如下SQL语句所示:123select teacher id + 5 MY_ID，concat(teacher_name，teacher_id) teacher_namefrom teacher_tablewhere teacher id*2 &gt; 3; 甚至可以在select、where子句中都不出现列名，如下SQL语句所示:123select 5 + 4from teacher_tablewhere 2 &lt; 9; 这种情况比较特殊: where语句后的条件表达式总是true,所以会把teacher_table表中的每条记录都选择出来一但SQL语句没有选择任何列，仅仅选择了一个常量，所以SQL会把该常量当成一列，teacher_table表中有多少条记录，该常量就出现多少次。对于选择常量的情形，指定数据表可能没有太大的意义，所以MySQL提供了一种扩展语法，允许select语句后没有from子句，即可写成如下形式:1select 5+ 4; 上面这种语句并不是标准SQL语句。例如, Oracle就提供了一个名为dual的虚表(最新的MySQL数据库也支持dual虚表)，它没有任何意义，仅仅相当于from后的占位符。如果选择常量，则可使用如下语句:1select 5+4 from dual; select默认会把所有符合条件的记录全部选出来，即使两行记录完全一样。如果想去除重复行，则可以使用distinct关键字从查询结果中清除重复行。比较下面两条SQL语句的执行结果：123456#选出所有记录，包括重复行select student_name, java_teacherfrom student_table;#去除重复行select distinct student_name, java_teacherfrom student_table; 使用distinct 去除重复行时，distinct 紧跟select关键字。它的作用是去除后面字段组合的重复值，而不管对应记录在数据库里是否重复。例如，(1,’a’,’b’)和(2,’a’,’b’)两条记录在数据库里是不重复的，但如果仅选择后面两列，则distinct会认为两条记录重复。 SQL中判断两个值是否相等的比较运算符是单等号,判断不相等的运算符是&lt;&gt;; SQL中的赋值运算符不是等号，而是冒号等号(:=). SQL还支持特殊的比较运算符 运算符 含义 exprl between expr2 and expr3 要求expr1&gt;= expr2并且expr2&lt; expr3 exprl in(expr2 , expr3 , expr4,…) 要求exprl等于后面括号里任意-一个表达式的值 like 字符串匹配，like 后的字符串支持通配符 is null 要求指定值等于null 下面的SQL语句选出student_id大于等于2，且小于等于4的所有记录。12select * from student_tablewhere student_id between 2 and 4; 使用between val1 and val2必须保证vall小于val2,否则将选不出任何记录。除此之外, between valland val2中的两个值不仅可以是常量,也可以是变量,或者是列名也行。如下SQL语句选出java_teacher小于等于2，student_id大于等于2的所有记录。12select * from student_tablewhere 2 between java_teacher and student_id; 使用in比较运算符时,必须在in后的括号里列出一个或多个值，它要求指定列必须与in括号里任意一个值相等。如下SQL语句所示:123#选出student id为2或4的所有记录select * from student_tablewhere student_id in(2, 4); 与之类似的是，in括号里的值既可以是常量，也可以是变量或者列名，如下SQL语句所示:123#选出student_id、java_teacher列的值为2的所有记录select * from student_tablewhere 2 in(student_id, java_teacher) ; like运算符主要用于进行模糊查询，例如，若要查询名字以“孙”开头的所有记录，这就需要用到模糊查询，在模糊查询中需要使用like关键字。SQL语句中可以使用两个通配符:下画线(_)和百分号(%),其中下画线可以代表一个任意的字符，百分号可以代表任意多个字符。如下SQL语句将查询出所有学生中名字以“孙”开头的学生。12select * from student_tablewhere student_name like '孙%; 下面的SQL语句将查询出名字为两个字符的所有学生。123select * from student_table#下面使用两个下画线代表两个字符where student_name like'__'; 在某些特殊的情况下，查询的条件里需要使用下画线或百分号，不希望SQL把下画线和百分号当成通配符使用，这就需要使用转义字符，MySQL使用反斜线() 作为转义字符，如下SQL语句所示:123#选出所有名字以下画线开头的学生select * from student_tablewhere student_name like '\\_%'; 标准SQL语句并没有提供反斜线() 的转义字符，而是使用escape关键字显式进行转义。例如，为了实现上面功能需要使用如下SQL语句:123#在标准的SQL中选出所有名字以下画线开头的学生select * from student_tablewhere student_name like '\\_% escape '\\'; is null用于判断某些值是否为空,判断是否为空不要用=null来判断,因为SQL null=null返回null。如下SQL语句将选择出student_table表中student_name为null的所有记录。12select * from student_tablewhere student_name is null; 如果where子句后有多个条件需要组合，SQL提供了and和or逻辑运算符来组合两个条件，并提供了not来对逻辑表达式求否。如下SQL语句将选出学生名字为2个字符，且student id大于3的所有记录。123select * from student_table#使用and来组合多个条件where student name like '__' and student_id &gt; 3; 下面的SQL语句将选出student_table表中姓名不以下画线开头的所有记录。123select * from student_table#使用not对where条件取否where not student_name like '\\_%' ; 当使用比较运算符、逻辑运算符来连接表达式时，必须注意这些运算符的优先级。SQL中比较运算符、逻辑运算符的优先级如表所示。 运算符 优先级（优先级小的优先） 所有的比较运算符 1 not 2 and 3 or 4 如果SQL代码需要改变优先级的默认顺序,则可以使用括号,括号的优先级比所有的运算符高如下SQL语句使用括号来改变逻辑运算符的优先级1234select * from student_table使用括号强制先计算or运算where (student_id &gt;3 or student_name &gt;'张'and java_teacher &gt;1; 执行査询后的查询结果默认按插入顺序排列;如果需要查询结果按某列值的大小进行排序,则可以使用order by子句。order by子句的语法格式如下:1order by column_namel [desc], column name2..... 进行排序时默认按升序排列,如果强制按降序排列,则需要在列后使用desc关键字(与之对应的是asc关键字,用不用该关键字的效果完全一样,因为默认是按升序排列)。 上面语法中设定排序列时可采用列名、列序号和列别名。如下SQL语句选出 student table表中的所有记录,选出后按 java_teacher列的升序排列。12select * from student_tableorder by java_teacher; 如果需要按多列排序,则每列的asc、desc必须单独设定。如果指定了多个排序列,则第一个排序列是首要排序列,只有当第一列中存在多个相同的值时,第二个排序列才会起作用。如下SQL语句先按 java_teacher列的降序排列,当java_teacher列的值相同时按student_name列的升序排列。12select from student_tableorder by java_teacher desc, student_name;","link":"/2019/01/24/MySQL基础/"},{"title":"Homebrew 相关操作","text":"homebrew常见命令，以安装Tomcat为例安装Tomcat(安装的是最新的版本)brew install tomcat卸载 Tomcatbrew uninstall tomcat更新brew upgrade tomcat更新不会删除原来的，相当于重新安装一个最新版，也就是说配置不能共用 切换版本brew switch tomcat 8.5.4升级会出现几个不同版本的 Tomcat 同时存在，切换到指定的版本就很有必要了 卸载卸载全部旧版本brew cleanup tomcat卸载当前版本brew remove tomcat卸载全部版本brew uninstall --force tomcat卸载指定版本brew switch tomcat 8.5.4brew remove tomcat查看已安装的 Tomcat 的版本和最新的版本信息brew info tomcat查看可安装的 Tomcat 的所有版本brew search tomcat 输出:homebrew/versions/tomcat6homebrew/versions/tomcat7tomcattomcat-native安装指定版本的 Tomcat，例如 tomcat6brew install homebrew/versions/tomcat6列出已经安装的软件brew list查看 brew 的帮助man brew列出所有安装的软件里可以升级的brew outdated清理不需要的版本极其安装包缓存brew cleanup Homebrew网络修改问题在国内的网络环境下使用 Homebrew 安装软件的过程中可能会长时间卡在 Updating Homebrew 这个步骤。例：执行 brew install composer 命令➜ ~ brew install composerUpdating Homebrew...如果碰到长时间卡在这里，参考以下 2 种处理方法方法1：按住 control + c 取消本次更新操作➜ ~ brew install composerUpdating Homebrew...^C按住 control + c 之后命令行会显示 ^C，就代表已经取消了 Updating Homebrew 操作大概不到 1 秒钟之后就会去执行我们真正需要的安装操作了 ➜ ~ brew install composerUpdating Homebrew...^C==&gt; Satisfying dependencies==&gt; Downloading https://getcomposer.org/download/1.7.2/composer.phar... 这个方法是临时的、一次性的 方法2：使用 Alibaba 的 Homebrew 镜像源进行加速平时我们执行 brew 命令安装软件的时候，跟以下 3 个仓库地址有关：brew.githomebrew-core.githomebrew-bottles通过以下操作将这 3 个仓库地址全部替换为 Alibaba 提供的地址 替换/还原 brew.git 仓库地址替换成阿里巴巴的 brew.git 仓库地址:cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/brew.git #======================================================= 还原为官方提供的 brew.git 仓库地址cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git 替换/还原 homebrew-core.git 仓库地址替换成阿里巴巴的 homebrew-core.git 仓库地址:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.aliyun.com/homebrew/homebrew-core.git #======================================================= 还原为官方提供的 homebrew-core.git 仓库地址cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git 替换/还原 homebrew-bottles 访问地址这个步骤跟你的 macOS 系统使用的 shell 版本有关系所以，先来查看当前使用的 shell 版本echo $SHELL3.1 zsh 终端操作方式替换成阿里巴巴的 homebrew-bottles 访问地址:echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.zshrcsource ~/.zshrc #======================================================= 还原为官方提供的 homebrew-bottles 访问地址vi ~/.zshrc 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置source ~/.zshrc3.2 bash 终端操作方式 替换 homebrew-bottles 访问 URL:echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles' &gt;&gt; ~/.bash_profilesource ~/.bash_profile #======================================================= 还原为官方提供的 homebrew-bottles 访问地址vi ~/.bash_profile 然后，删除 HOMEBREW_BOTTLE_DOMAIN 这一行配置source ~/.bash_profile zsh配置代理shadowsocks设置为： 打开shadowsocks 自动代理模式 服务器（香港阿里云） 以zsh作为说明➜ ~ vim ~/.zshrc 添加如下代理配置:#proxy listalias proxy='export all_proxy=socks5://127.0.0.1:1080'alias unproxy='unset all_proxy' :wq保存退出➜ ~ source ~/.zshrc 使用proxy前先查看下当前的ip地址：➜ ~ curl [ip.cn](http://ip.cn) 当前 IP：112.64.xxx.xx 来自：上海市 联通 或者➜ ~ curl [cip.cc](http://cip.cc)IP : 140.206.97.42地址 : 中国 上海数据二 : 上海市 | 联通URL : http://www.cip.cc/140.206.97.42 执行:➜ ~ proxy➜ ~ curl [ip.cn](http://ip.cn)当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云 如果ip.cn不能用，可以换个类似的站点查询➜ ~ curl [cip.cc](http://cip.cc)IP : 45.78.47.19地址 : 美国 加利福尼亚数据二 : 美国 | 加利福尼亚州洛杉矶市 IT7 NetworksURL : http://www.cip.cc/45.78.47.19 没问题，终端走了代理，brew update顺畅了- -如果不需要走代理，执行：➜ ~ unproxy➜ ~ curl [ip.cn](http://ip.cn)当前 IP：112.64.xxx.xx 来自：上海市 联通 proxychains-ng➜ ~ brew install proxychains-ngUpdating Homebrew…","link":"/2019/01/30/Homebrew常见命令/"}],"tags":[{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"NOSQL","slug":"NOSQL","link":"/tags/NOSQL/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"homebrew","slug":"homebrew","link":"/tags/homebrew/"},{"name":"macOS","slug":"macOS","link":"/tags/macOS/"}],"categories":[]}