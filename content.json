{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/01/18/hello-world/"},{"title":"Java IO流","text":"简介 Java的IO通过java.io包下的类和接口来支持，在java.io包下主要包括输入、输出流又可分为字节流和字符流两大类。其中字节流以字节为单位来处理输入和输出操作，而字符流以字符来处理输入和输出操作。此外Java的IO流使用了装饰器设计模式，它将IO流分为底层节点流和上层处理流，其中节点流和底层的物理存储节点直接关联——不同的物理节点获取节点流的方式存在差异，但程序可以把不同的物理节点包装成统一的处理流，从而允许程序使用统一的输入、输出代码来读取不同的物理存储节点的资源.Java7在java.nio及其子包下提供了一系列全新的API，这些API是对原有新IO的升级，因此也被称为NIO2，通过这些NIO2，程序可以更高效地进行输入、输出操作。除此之外，Java还使用了对象的序列化机制，通过序列化机制可以把内存中的Java对象转换成二进制字节流，这样就可以把Java对象存储到磁盘里，或者在网络上传输Java对象。 File类File类是java.io包下代表和平台无关的文件和目录，不管是文件还是目录DOI是使用File来操作的，File能创建、删除、重命名文件和目录，File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入流、输出流 访问文件和目录File类可以使用文件路径字符串来创建File实例该文件路径既可以是绝对路径，也可以是相对路径。在默认情况下，系统总是根据用户的工作路径来解释相对路径一旦创建了File对象，就可以调用File对象的方法来访问，File类提供了很多方法来操作文件和目录 1.访问文件名相关的方法 String getName():返回此File对象表示的文件名或者路径名 String getPath():返回此File对象所对应的路径名 File getAbsoultFile()：返回此File对象的绝对路径 String getParent()：返回此File对象所对应目录的父目录名。 boolean renameTo(File newName):重命名此File对象所对应的文件或者目录，如果重命名成功，则返回true，否则返回false。 2.文件检测相关 boolean exists()；判断File对象所对应的文件或者目录是否存在 boolean canWrite():判断File对象所对应的文件和目录是否能写 boolean canRead():判断按File对象所对应的文件和目录是否能读 boolean isFile()：判断File对象所对应的是否文件，而不是目录 boolean isDirectory()：判断File对象是否是目录，而不是文件 boolean isAbsolute():判断File对象所对应的文件和目录是否是绝对路径。该方法消除了平台差异，可以直接判断File对象是否为绝对路径。在Unix/Linux/BSD系统上，如果路径名开头是一条斜线，则表明该File对象是一个绝对路径；在Windows等系统上，如果路径开头是盘符，则说明它是一个绝对路径 3.获取常规文件信息 long lastModified():返回文件最后的修改时间 long length():返回文件内容的长度 4.文件操作相关 boolean createNewFile();当此filed对象所对应的文件不存在时，该方法将新建一个该file对象所指定的新文件，如果创建成功则返回true，否则返回false boolean delete()：删除File对象所对应的文件或者路径 static File createTempFile(String prefix,String suffix):在默认的临时文件目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接使用File类来调用。prefix参数必须至少是3字节长。建议前缀使用一个短的，有意义的字符串，如“mail”后缀参数可以是null，在这种情况下默认的后缀是“.tmp” static File createTempFile(String prefix,String suffix,File directory):在directory所指定的目录中创建一个临时的空文件，使用给定的前缀、系统生成的随机数和给定的后缀作为文件名，这是一个静态方法，可以直接通过File类来调用 void deleteOnExit():注册一个删除钩子，当Java虚拟机退出时候，删除File对象所对应的文件和目录 5.目录操作相关的方法 boolean mkdir():试图创建一个File对象对应的目录。调用该方法时File对象必须是一个路径，而不是一个文件 String[] list():列出File对象的所有字文件名和路径名，返回String数组 File[] listFile():列出File对象所有子文件和路径，返回File数组 static File[] listRoots():列出系统所有的根目录。 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.File;import java.io.IOException;public class FileTest { public static void main(String[] args) throws IOException { File file = new File(\".\"); System.out.println(file.getName()); System.out.println(file.getParent()); System.out.println(file.getAbsoluteFile()); //获取的是string，上面的获取的是file System.out.println(file.getAbsolutePath()); System.out.println(file.getAbsoluteFile().getParent()); //在当前目录下车间一个临时文件 File tmpfile=File.createTempFile(\"aaa\",\".txt\",file); //当jvm退出时候删除此文件 tmpfile.deleteOnExit(); //以系统当前时间作文新文件名来创建新文件 File newFile = new File(System.currentTimeMillis()+\"\"); System.out.println(newFile.exists()); //以指定newFile对象来创建一个文件 newFile.createNewFile(); //以newFile对象来创建一个目录，因为newFile已经存在所以下面方法返回false，即无法创建该目录 newFile.mkdir(); //使用list方法列出当前路径下的所有文件和路径 System.out.println(\"---------\"); String[] filelist = file.list(); for (String filename:filelist){ System.out.println(filename); } System.out.println(\"---------\"); //listroot()静态方法查看所有的根目录 File[] roots = File.listRoots(); for (File root:roots){ System.out.println(root); } }}/* 程序列出当前文件和路径时，列出了程序创建的临时文件，但程序运行结束后，aaa.txt 并不存在，因为程序制定虚拟机退出时自动删除了该文件。上面程序还有一点要注意的是 当使用相对路径的File对象来获取父类路径的时候可能会出差，因为该方法返回将File对象 所对应的目录名、文件名里最后一个子目录名、子文件名删除后的结果 */ 文件过滤器在File类的list()方法中可以接收一个FilenameFilter参数，通过该参数只列出符合条件的文件，FilenameFilter接口里包含了一个accept(File dir,String name)方法，该方法将依次对指定File的所有子目录或者文件进行迭代，如果返回true，则list()方法会列出子目录或者文件123456789101112import java.io.File;public class FilenameFilterTest { public static void main(String[] args) { File file = new File(\".\"); //使用lambda表达式，（目标类型是FilenameFilter）实现文件过滤 String[] nameList = file.list((dir,name)-&gt;name.endsWith(\".java\")|| new File(name).isDirectory()); for (String name:nameList){ System.out.println(name); } }} 上面的程序部分实现了accept()方法，实现accept()方法就是指定自己的规则，指定哪些文件由list()方法列出。FilenameFilter接口内只有一个抽象方法，因此该接口也是一个函数式接口，可使用lambda表达式创建实现该接口的对象 理解Java的IO流 Java的IO流是实现输入、输出的基础，可以方便得实现数据的输入输出操作，在Java中把不同的输出输出源抽象表述为“流”，通过流的方式允许Java程序使用相同的方式来访问不同的输入、输出源，Java中把所有传统的流类型都放在java.io包中，用以实现输入输出功能。 流的分类1.输入和输出流 输入流：只能从中读取数据，而不能向其写入数据。 输出流：只能向其中写数据，而不能从中读取数据。 注：输入输出涉及到一个方向的问题，数据从内存到硬盘，通常称为输出流——也就是说，这里的输入输出都是从程序运行所在内存的角度而划分的。数据从服务器通过网络流向客户端，在这种情况下，Server端的内存负责将数据输出到网络当中，因此Server端使用的是输出流，Client端的内存负责从网络里读取数据，因此Client端的程序应该使用输入流。Java中的输入流主要由InputStream和Reader作为基类，而输出流主要由OutputStream和Writer作为基类。都是一些抽象基类，无法直接创建实例。 2.字节流和字符流字节流和字符流使用方法几乎一样，区别在于所操作的数据单元不同——字节流操作的数据单元是8位的字节，而字符流操作的数据单元是16位的字符字节流主要由InputStream和OutputStream作为基类，而字符流主要由Reader和Writer作为基类。 3.节点流和处理流按照流的角色来分，可以分为节点流和处理流可以从/向一个特定的IO设备(如磁盘、网络)读/写数据的流，称为节点流，节点流也被称为低级流使用节点流进行输入、输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。处理流则是用于对一个已经存在的流进行连接或者封装，通过封装后的流实现读写数据的功能，也被称为高级流。使用处理流的时候，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入输出代码来访问不同的数据源，随着处理流包装节点流的变化，程序实际所访问的数据源也相应地发生变化。注：Java使用处理流来包装节点是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来玩成输入、输出功能。因此处理流也被称为包装流 流的模型概念Java把所有设备里有序数据抽象成流模型，简化了输出、输出处理，Java的IO流涉及了40多个类，都是由如下4个抽象基类派生的。 InputStream/Reader 所有输入流的基类，前者是字节输入流，后者是字符输入流 OutputStream/Writer：所有输出流的基类前者是字节输出流，后者是字符输出流。 处理流的功能主要体现在以下两个方面 性能的提高：主要以增加缓冲的方式来提高输入/输出效率。 操作的便捷：处理流可能提供一系列便捷的方法来一次输入/输出大批量的内容，而不是一个 处理流可以“嫁接”在任何已经存在的流的基础之上，这就允许Java应用程序采用相同的代码、透明的方式来访问不同的输入/输出设备的数据流。通过使用处理流，Java程序无需理会输入/输出节点是磁盘、网络还是其他的输入输出设备，程序只要将这些节点包装成处理流，就可以使用相同的输入/输出代码来读写不同的输入/输出设备的数据 字节流和字符流InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可以使用的方法在InputStream里包含如下三个方法 int Read():从输入流中读取单个字节，返回所读取的字节数据（字节数据可以直接转换为int类型） int Read(byte[] b):从输入流中最多读取b.length()个字节数据，并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[] b,int off,int len)从输入流中最多读取len个字节数据，并将其存储在b数组中，从off开始读写。 Read中的三个基本方法 int Read():从输入流中读取单个字符，返回所读取的字符数据(字符数据可以直接转换为int类型) int Read(char[] cbuf): int Read(char[] cbuf,int off,int len); 以上两个方法都是其方法返回值为-1时候，表示输入流的终点。InputStream和Reader都是抽象类，本身不能创建实例，但它们分别都有一个用于读取文件的输入流FileInputStream和FileReader，它们都是节点流——会直接和指定文件关联 12345678910111213141516import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamTest { public static void main(String[] args) throws IOException { //创建字节输入流 FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); //创建一个长度为1024的数组 byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = fis.read(bbuf)) &gt;0){ System.out.println(new String(bbuf,0,hasRead)); } fis.close(); }} 注：上面的代码创建了一个长度为1024的字节数组来读取该文件，也就是说，程序只需要执行一次read()就能读取全部内容。但如果创建较小长度的字节数组，程序在运行时候输出中文注释的时候就会出现乱码————这是因为文件保存时候采用的是GBK编码方式，在这种方式下，每个中文字符占2个字节，如果只读取了半个中文字符，就会导致乱码 123456789101112131415161718import java.io.FileReader;import java.io.IOException;public class FileReaderTest { public static void main(String[] args) { try( FileReader fr = new FileReader(\"./IO/src/FileReaderTest.java\")){ //创建一个长度为32的char数组 char[] cbuf = new char[32]; int hasRead = 0; while ((hasRead=fr.read(cbuf))&gt;0){ System.out.println(new String(cbuf,0,hasRead)); } }catch (IOException io){ io.printStackTrace(); } }} FileReaderTest.java和以上的程序并没有太大的不同，程序只是将字符数组长度改成了32，意味着程序要多次调用read()方法才可能完全读取输入流的全部数据。程序最终使用了自动关闭资源的try语句来关闭文件的输入流，此外InputStream和Reader还支持如下几种方式来移动记录指针 void mark(int c):将指定的字节/字符输出到输出流中，其中c既可以代表字节，也可以代表字符。 boolean markSupported():判断此输入流是否支持mark操作，即是否支持记录标记 void reset()：将此流记录指针重新定位到上一次记录标记mark的位置 long skip(long n)：记录指针向前移动n个字符/字节 OutputStream和Witer void write(int c):将指定的字节/字符输出到输出流中，其中c即可代表字节，也可以代表字符 void write(byte[]/char[] buff):将字符数组/字节数组的数据输出到指定输出流中 void write(byte[]/char[] buff,int off,int len):将字节数组/字符数组从off位置开始，长度为len的字节/字符输出到输出流中。 因为字符流操作直接是以字符为操作单位，所以Writer可以使用字符串来代替字符数组，Writer还包含如下两个方法。 void write(String str):将str字符串里包含的字符输出到指定的输出流中 void write(String str,int off,int len):将str字符串里从off开始输出到指定的输出流中去。 下面的程序使用FileInputStream来执行输入，并使用FileOutPutStream来输出123456789101112131415161718import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileOutputStreamTest { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/FileInputStreamTest.java\"); FileOutputStream fos = new FileOutputStream(\"newfile.txt\")){ byte[] bbuf = new byte[32]; int hasRead = 0; while ((hasRead=fis.read(bbuf))&gt;0){ fos.write(bbuf,0,hasRead); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 注：使用Java的IO执行输出的时候，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，可能还可以将输出流缓冲区的数据flush到物理节点（因为在执行close()方法之前，自动执行输出流flush()方法）。Java中很多输出流默认都提供了缓存功能，无需刻意记忆哪些流有缓冲功能、哪些没有、只要正常关闭所有的输出流即可保证程序正常。 如果希望直接输出字符串内容，使用Writer效果会好一点12345678910111213import java.io.FileWriter;import java.io.IOException;public class FileWriterTest { public static void main(String[] args) { try(FileWriter fw = new FileWriter(\"poem.txt\")){ fw.write(\"锦瑟\"); fw.write(\"锦瑟无端五十弦，一弦一柱思华年。\\r\\n\"); fw.write(\"庄生晓梦迷蝴蝶，望帝春心托杜鹃.\\r\\n\"); }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序在输出字符串内容的时候，字符串后面是\\r\\n,这是Windows平台的换行符，通过这种方式就可以让输出内容换行，如果是Linux/Unix/BSD等平台，则使用\\n作为换行符即可 输入/输出流体系上面介绍了4个文件的节点流的使用方法，但是4个基类使用有些繁琐，简化开发，就需要使用到了处理流了。 处理流的用法处理流可以隐藏底层设备上的节点流的差异，并对外提供更加方便的输入/输出方法。使用处理流思路是，使用处理流来保证节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的I/O设备，文件交互。实际识别处理流十分简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，那么这种流就一定是处理流；而所有节点流都是直接以物理IO节点作为构造器参数的。 使用处理流的优势1.对于开发人员来说，使用处理流进行输入/输出操作更加简单。2.使用处理流的执行效率更高 1234567891011121314151617181920import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class PrintStreamTest { public static void main(String[] args) { try( FileOutputStream fos = new FileOutputStream(\"text.txt\"); PrintStream ps = new PrintStream(fos); ){ //使用PrintStream执行输出 ps.println(\"普通字符\"); //直接使用PrintStream输出对象 ps.println(new PrintStreamTest()); } catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中定义了一个节点输出流FileOutputStream, 然后程序使用PrintStream包装了该节点输出流，最后使用PrintStream输出字符串、输出对象..PrintStream的输出功能非常强大，标准输出System.out的类型就是PrintStream。在使用处理流包装了底层节点流之后，关闭输入/输出流资源时，只要关闭最上层的处理流即可。关闭最上层的处理流时，系统会自动关闭被该处理流包装的节点流。 输入/输出体系java的输入输出体系提供了接近40个类，之所以如此复杂是因为实现更好的设计，把IO流按功能分成了很多的类，而每个类有分别提供了字节流和字符流，字节流字符流又分为输入流输出流两大类。 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream FilterOutPutStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInptStream DataOutputStream 通常来说，字节流的功能比字符流的功能强大的多，因为计算机中数据大多数是二进制文件。问题是如果使用字节流来处理文本，则需要使用合适的方式把字节字节转换为字符，会增加编程的难度。所以通常有一个规则：如果进行输入/输出的内容是文本内容，则应该考虑使用字符流；如果进行输入/输出的内容是二进制内容，就应该考虑使用字节流 上面的表中还列出了以数组为物理节点的字节流，字节流以字节数组为节点，字符流以字符数组为节点；这种数组为物理节点的节点流消除了创建节点流对象时，需要传入应该字节数组或者字符数组之外，用法上与文件节点流完全相似。字符流还可以使用字符串作为物理节点，用于实现从字符串读取内容，或将内容写入字符串（StringBuffer充当字符串），下面程序示范了使用字符串作为物理节点的字符输入/输出流的用法 1234567891011121314151617181920212223242526272829303132333435363738import java.io.IOException;import java.io.StringReader;import java.io.StringWriter;public class StringNodeTest { public static void main(String[] args) { String src = \"从明天起，做一个幸福的人\\n\" + \"喂马劈柴，周游世界\\n\" + \"从明天起，关心粮食和蔬菜\\n\" + \"我有一所房子，面朝大海，春暖花开\\n\"; char[] buff = new char[32]; int hasRead = 0; try ( StringReader sr = new StringReader(src)) { while ((hasRead = sr.read(buff)) &gt; 0) { System.out.println(new String(buff, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } try ( //创建StringWriter时，实际上以一个StringBuffer作为输出节点 //下面就是指定的20就是StringBuffer的初始长度 StringWriter sw = new StringWriter() ) { sw.write(\"有一个美丽的世界\"); sw.write(\"她在远方等我\"); sw.write(\"那里有天真的孩子\"); sw.write(\"还有姑娘的酒窝\"); System.out.println(\"------下面是sw字符串节点里的内容-----\"); System.out.println(sw.toString()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序与前面使用FileReader和FileWriter的程序基本相似，只是在创建StringReader和StringWriter对象时传入的是字符串节点，而不是文件节点。由于String是不可变的字符串对象，所以StringWriter使用StringBuffer作为输出节点。 转换流输入/输出流体系中还提供了两个转换流，这两个转换流用于实现将字节流转换成字符流，其中InputStreamReader将字节输入流转换成字符输入流，OutputStreamWriter 将字节输出流转换成字符输出流。 问：为什么没有把字符流转换为字节流的转换流？ 想一想字符流和字节流的差别:字节流比字符流的使用范围更广，但字符流比字节流操作方便。如果有一个流已经是字符流了，也就是说，是一个用起来更方便的流，为什么要转换成字节流呢?反之，如果现在有一个字节流，但可以确定这个字节流的内容都是文本内容，那么把它转换成字符流来处理就会更方便一些，所以Java只提供了将字节流转换成字符流的转换流，没有提供将字符流转换成字节流的转换流。 12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class KeyinTest { public static void main(String[] args) { try ( //将System.in对象转换为Reader对象 InputStreamReader reader = new InputStreamReader(System.in); //将普通的Reader包装成BufferedReader BufferedReader br = new BufferedReader(reader) ) { String line = null; //采取循环的方式来读取 while ((line = br.readLine()) != null) { //如果读取字符串是exit，则程序退出 if (line.equals(\"exit\")) { System.exit(1); } //打印读取内容 System.out.println(\"输入内容：\" + line); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中 的粗体字代码负责将System.in包装成BufferedReader, BufferedReader流具有缓冲功能，它可以一次读取一行文本——一以换行符为标志， 如果它没有读到换行符，则程序阻塞，等到读到换行符为止。运行上面程序可以发现这个特征，在控制台执行输入时,只有按下回车键,程序才会打印出刚刚输入的内容。由于BufferedReader具有一个readLine()方法，可以非常方便地一次读入一行内容，所以经常把读取文本内容的输入流包装成BufferedReader,用来方便地读取输入流的文本内容。 推回输入流在输入/输出流体系中，有两个特殊的流与众不同，就是PushbackInputStream和PushbackReader,它们都提供了如下三个方法。 void unread(byte[]/char[]bu):将一个字节/字符数组内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(byte[]/char[] b, int off, int len);将一个字 节/字符数组里从off开始，长度为len字节/字符的内容推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 void unread(intb):将一个字节/字符推回到推回缓冲区里，从而允许重复读取刚刚读取的内容。 这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区里，而推回输入流每次调用read()方法时总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read()所需的数组时才会从原输入流中读取。当程序创建一个PushbackInputStream和PushbackReader时需要指定推回缓冲区的大小，默认的推回缓冲区的长度为1。如果程序中推回到推回缓冲区的内容超出了推回缓冲区的大小，将会引发Pushback buffer overflow的IOException异常。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.FileReader;import java.io.IOException;import java.io.PushbackReader;public class PushbackTest { public static void main(String[] args) { try ( //创建一个PushbackReader对象，指定推回缓冲区的长度为64 PushbackReader pr = new PushbackReader(new FileReader(\"./IO/src/PushbackTest.java\"), 64); ) { char[] buff = new char[32]; // 用以保存上次读取的字符串内容 String lastContent = \"\"; int hasRead = 0; //循环读取文件 while ((hasRead = pr.read(buff)) &gt; 0) { //将读取的内容转换为字符串 String content = new String(buff, 0, hasRead); int targetIndex = 0; //将上次读取的字符串和本次读取的字符串拼接起来 if ((targetIndex = (lastContent + content).indexOf(\"new PushbackReader\")) &gt; 0) { //将本次内容和上次内容一起推回缓冲区 pr.unread((lastContent + content).toCharArray()); //重新定义一个长度为targetIndex的char数组 if (targetIndex &gt; 32) { buff = new char[targetIndex]; } //再次读取指定长度的内容（就是目标字符串之前的内容） pr.read(buff, 0, targetIndex); //打印读取的内容 System.out.println(new String(buff, 0, targetIndex)); System.exit(0); } else { //打印上次读取的内容 System.out.println(lastContent); //将本次内容设为上次读取的内容 lastContent = content; } } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的粗体字代码实现了将指定内容推回到到推回缓冲区，于是当程序再次调用read方法时，实际上只读取了推回缓冲区的部分内容，从而实现了只打印目标字符串前面的内容 重定向标准输入/输出Java 的标准输入/输出分别通过System.in和System.out来代表，在默认情况下它们分别代表键盘和显示器，程序通过System.in来获取输入时，实际上是从键盘读取输入;当程序试图通过Syste m.out执行输出时，程序总是输出到屏幕。 在System类里提供了如下三个重定向标准输入/输出的方法。 static void setErr(PrintStreamer):重定向“标准”错误输出流。 static void setIn(InputStream in):重定向“标准”输入流。 static void setOut(PrintStream out):重定向“标准”输出流。 下面程序通过重定向标准输出流，将System.out的输出重定向到文件输出，而不是在屏幕上输出。 123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;import java.io.PrintStream;public class RedirectOut { public static void main(String[] args) { try ( //一次性创建printStream输出流 PrintStream ps = new PrintStream(new FileOutputStream(\"out.txt\")) ) { //将标准流定向到ps System.setOut(ps); System.out.println(\"普通字符串\"); //向标准输出一个对象 System.out.println(new RedirectOut()); } catch (IOException ioe) { ioe.printStackTrace(); } }} 下面程序采用重定向标准输入，从而可以将System.in重定向到指定文件，而不是键盘输入。123456789101112131415161718192021222324import java.io.FileInputStream;import java.io.IOException;import java.util.Scanner;public class RedirectIn { public static void main(String[] args) { try( FileInputStream fis = new FileInputStream(\"./IO/src/RedirectIn.java\") ){ System.setIn(fis); //使用System.in创建Scanner对象，用于获取标准输入 Scanner sc = new Scanner(System.in); //增加下面一行只把回车作为分隔符 sc.useDelimiter(\"\\n\"); //判断下面一行是否还有输出项目 while (sc.hasNext()){ //输入输出项 System.out.println(\"键盘输入的内容是\"+sc.next()); } }catch (IOException ioe){ ioe.printStackTrace(); } }} 上面程序中的粗体字代码创建了一个FileInputStream输入流,并使用System的setln()方法将系统标准输入重定向到该文件输入流。运行上面程序，程序不会等待用户输入，而是直接输出了Redireetnjava文件的内容，这表明程序不再使用键盘作为标准输入，而是使用Redirectln.java文件作为标准输入源。 Java虚拟机读写其他进程的数据使用Runtime对象的exec()方法可以运行平台上的其他程序，该法产生一个Process对象，Process对象代表由该Java程序启动的子进程。Process 类提供了如下三个方法，用于让程序和其子进程进行通信。 InputStream getErrorStream():获取子进程的错误流。 InputStream getlnputStream():获取子进程的输入流。 InputStream getOutputStream():获取子进程的输出流。 如果试图让子程序读取程序中的数据，那么应该使用的是输出流。因为站在Java程序的角度来看，子进程读取Java程序的数据，就是让Java程序吧数据输出到子程序中（就像把数据输出到文件中一样，只是现在由子进程代替了文件节点），所以应该使用输出流。 RandomAccessFileRandomAccessFile是Java输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是，只需要访问文件部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。 与OutputStream、 Writer等输出流不同的是，RandomAccessFile 允许自由定位文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile. RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他10节点。 RandomAccessFile对象也包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件记录指针位于文件头(也就是0处)，当读/写了n个字节后，文件记录指针将会向后移动n个字节。除此之外，RandomAccessFile可以自由移动该记录指针,既可以向前移动，也可以向后移动。RandomAccessFile 包含了如下两个方法来操作文件记录指针。 long getFilePointer):返回文件记录指针的当前位置。 void seek(long pos):将文件记录指针定位到pos位置。 RandomAccessFile既可以读文件，也可以写，所以它既包含了完全类似于InputStream的三个read()方法,其用法和InputStream的三个read()方法完全一样;也包含了完全类似于OutputStream的三个write()方法，其用法和OutputStream的三个write()方法完全一样。 除此之外，RandomAccessFile 还包含了一系列的readXxx()和writeXxx()方法来完成输入、输出。 RandomAccessFile类有两个构造器,其实这两个构造器基本相同,只是指定文件的形式不同而已一个使用String参数来指定文件名,一个使用File 参数来指定文件本身。除此之外,创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，该参数有如下4个值。 “r”: 以只读方式打开指定文件。如果试图对该RandomAccessFile 执行写入方法，都将抛出IOException异常。 “rw”: 以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。 “rws”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。 “rwd”: 以读、写方式打开指定文件。相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。下面程序使用了RandomAccessFile来访问指定的中间部分数据。1234567891011121314151617181920212223import java.io.IOException;import java.io.RandomAccessFile;public class RandomAccessFileTest { public static void main(String[] args) { try ( RandomAccessFile raf = new RandomAccessFile(\"./IO/src/RandomAccessFileTest.java\", \"r\") ) { //获取RandomAccessFile对象文件指针的位置，初始位置为0 System.out.println(\"RandomAccessFile的文件指针的初始位置\" + raf.getFilePointer()); //移动raf的文件记录指针的位置 raf.seek(300); byte[] bbuf = new byte[1024]; //用于保存实际读取的字节数 int hasRead = 0; while ((hasRead = raf.read(bbuf)) &gt; 0) { System.out.println(new String(bbuf, 0, hasRead)); } } catch (IOException ioe) { ioe.printStackTrace(); } }} 上面程序中的代码创建了一个RandomAccessFile对象，该对象以只读方式打开了RandomAccessFileTest.java文件,这意味着该RandomAccessFile对象只能读取文件内容,不能执行写入。程序中第二行粗体字代码将文件记录指针定位到300处，也就是说，程序将从300字节处开始读、写，程序接下来的部分与使用InputStream读取并没有太大的区别。运行上面程序，将看到程序只读取后面部分的效果。 下面程序示范了如何向指定文件后追加内容，为了追加内容,程序应该先将记录指针移动到文件最后，然后开始向文件中输出内容。12345678910111213141516import java.io.IOException;import java.io.RandomAccessFile;public class AppendContent { public static void main(String[] args) { try ( //1.以读写方式打开一个RandomAccessFile对象 RandomAccessFile raf = new RandomAccessFile(\"out.txt\", \"rw\"); ) { raf.seek(raf.length()); raf.write(\"追加的内容！\\r\\n\".getBytes()); } catch (IOException ioe) { ioe.printStackTrace(); } }} RandomAccessFile依然不能向文件的指定位置插入内容,如果直接将文件记录指针移动到中间某位置后开始输出，则新输出的内容会覆盖文件中原有的内容。如果需要向指定位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等把需要插入的数据写入文件后，再将缓冲区的内容追加到文件后面。 12345678910111213141516171819202122232425262728293031323334353637import java.io.*;public class InsertContext { public static void insert(String fileName, long pos, String insertContext) throws IOException { File tmp = File.createTempFile(\"tmp\", null); tmp.deleteOnExit(); try ( RandomAccessFile raf = new RandomAccessFile(fileName, \"rw\"); //使用临时文件来保存插入点后的数据 FileOutputStream tmpOut = new FileOutputStream(tmp); FileInputStream tmpIn = new FileInputStream(tmp); ) { raf.seek(pos); //-------下面代码将插入点之后的内容读入临时文件中保存 byte[] bbuf = new byte[64]; //用于保存实际读取的字节数 int hasRead = 0; //循环读取插入点后的数据 while ((hasRead=raf.read(bbuf))&gt;0){ tmpOut.write(bbuf,0,hasRead); } //下面代码用于插入 raf.seek(pos); raf.write(insertContext.getBytes()); //追加临时文件的内容 while((hasRead=tmpIn.read(bbuf))&gt;0){ raf.write(bbuf,0,hasRead); } } catch (IOException ioe) { ioe.printStackTrace(); } } public static void main(String[] args)throws IOException { insert(\"./IO/src/InsertContent.java\",45,\"插入的内容\\r\\n\"); }} 上面程序中 使用File的createTempFile(String prefix, String suffix)方法创建了一个临时文件(该临时文件将在JVM退出时被删除),用以保存被插入文件的插入点后面的内容。程序先将文件中插入点后的内容读入临时文件中,然后重新定位到插入点，将需要插入的内容添加到文件后面,最后将临时文件的内容添加到文件后面，通过这个过程就可以向指定文件、指定位置插入内容。每次运行上面程序，都会看到向InsertContentjava中插入了一行字符串。 多线程断点的网络下载工具(如FlashGet等)就可通过RandomAccessFile类来实现，所有的下载工具在下载开始时都会建立两个文件:一个是与被下载文件大小相同的空文件，一个是记录文件指针的位置文件，下载工具用多条线程启动输入流来读取网络数据, 并使用RandomAccessFile将从网络上读取的数据写入前面建立的空文件中，每写一些数据后，记录文件指针的文件就分别记下每个RandomAccessFile当前的文件指针位置一网络断开后，再次开始下载时，每个RandomAccessFile都根据记录文件指针的文件中记录的位置继续向下写数据。","link":"/2019/01/23/Java IO/"},{"title":"MySQL基础","text":"关系型数据库基本概念严格来说，数据库(Database)仅仅是存放用户数据的地方。当用户访问、操作数据库中的数据时，就需要数据库管理系统的帮助。数据库管理系统的全称是Database Management System,简称DBMS。习惯上常常把数据库和数据库管理系统笼统地称为数据库,通常所说的数据库既包括存储用户数据的部分，也包括管理数据库的管理系统。 DBMS是所有数据的知识库，它负责管理数据的存储、安全、一致性、并发、恢复和访问等操作。DBMS有一个数据字典(有时也被称为系统表)，用于存储它拥有的每个事务的相关信息，例如名字、结构、位置和类型，这种关于数据的数据也被称为元数据(metadata)。 在数据库发展历史中，按时间顺序主要出现了如下几种类型的数据库系统。 网状型数据库 层次型数据库 关系数据库 面向对象数据库 在上面4种数据库系统中，关系数据库是理论最成熟、应用最广泛的数据库。从20世纪70年代末开始，关系数据库理论逐渐成熟，随之涌现出大量商用的关系数据库。关系数据库理论经过30多年的发展已经相当完善，在大量数据的查找、排序操作.上非常成熟且快速,并对数据库系统的并发、隔离有非常完善的解决方案。 面向对象数据库则是由面向对象编程语言催生的新型数据库，目前有些数据库系统如Oracle11g等开始增加面向对象特性，但面向对象数据库还没有大规模地商业应用。 对于关系数据库而言,最基本的数据存储单元就是数据表，因此可以简单地把数据库想象成大量数据表的集合(当然，数据库绝不仅由数据表组成)。 数据表是存储数据的逻辑单元，可以把数据表想象成由行和列组成的表格,其中每一行也被称为一条记录，每一列也被称为一个字段。为数据库建表时，通常需要指定该表包含多少列，每列的数据类型信息,无须指定该数据表包含多少行一因为 数据库表的行是动态改变的,每行用于保存一条用户数据。除此之外，还应该为每个数据表指定一个特殊列，该特殊列的值可以唯一地标识此行的记录，则该特殊列被称为主键列。 MySQL基本命令MySQL数据库的一个实例(Server Instance)可以同时包含多个数据库，MySQL 使用如下命令来查看当前实例下包含多少个数据库: show database; MySQL默认以分号作为每条命令的结束符，所以在每条MySQL命令结束后都应该输一个英文分号(;). 如果用户需要创建新的数据库，则可以使用如下命令:create database [IF NOT EXISTS] 数据库名; 如果用户需要删除指定数据库，则可以使用如下命令:drop database 数据库名; 建立了数据库之后，如果想操作该数据库(例如为该数据库建表，在该数据库中执行查询等操作),则需要进入该数据库。进入指定数据库可以使用如下命令:use 数据库名; 进入指定数据库后，如果需要查询该数据库下包含多少个数据表，则可以使用如下命令:show tables; 如果想查看指定数据表的表结构(查看该表有多少列，每列的数据类型等信息)，则可以使用如下命令:desc表名 MySQL基本登录命令 mysql -P 密码 -u 用户名 -h 主机名 --default-character-set=utf8 MySQL数据库通常支持如下两种存储机制。 MyISAM:这是MySQL早期默认的存储机制，对事务支持不够好。 InnoDB: InnoDB 提供事务安全的存储机制。InnoDB 通过建立行级锁来保证事务完整性，并以Oracle风格的共享锁来处理Select语句。系统默认启动InnoDB存储机制,如果不想使用InnoDB表，则可以使用skip-innodb选项。 对比两种存储机制，不难发现InnoDB比MyISAM多了事务支持的功能，而事务支持是Java EE最重要的特性，因此通常推荐使用InnoDB存储机制。如果使用5.0以上版本的MySQL数据库系统,通常无须指定数据表的存储机制，因为系统默认使用InnoDB存储机制。如果需要在建表时显式指定存储机制，则可在标准建表语法的后面添加下面任意一句。 ENGINE=MyISAM 强制使用MyISAM存储机制。 ENGINE=InnoDB 强制使用InnoDB存储机制。 SQL语句基础SQL的全称是Structured Query Language,也就是结构化查询语言。SQL是操作和检索关系数据库的标准语言，标准的SQL语句可用于操作任何关系数据库。 使用SQL语句，程序员和数据库管理员(DBA) 可以完成如下任务。 在数据库中检索信息。 对数据库的信息进行更新。 改变数据库的结构。 更改系统的安全设置。 增加或回收用户对数据库、表的许可权限。 在上面5个任务中，一般程序员可以管理前3个任务，后面2个任务通常由DBA来完成。 标准的SQL语句通常可分为如下几种类型。 查询语句:主要由select关键字完成，查询语句是SQL语句中最复杂、功能最丰富的语句。 DML(Data Manipulation Language,数据操作语言)语句:主要由insert、update 和delete三个关键字完成。 DDL(Data Definition Language, 数据定义语言)语句:主要由create、alter、 drop 和truncate四个关键字完成。 DCL(Data Control Language,数据控制语言)语句:主要由grant和revoke两个关键字完成。 事务控制语句:主要由commit、rollback 和savepoint三个关键字完成。 SQL语句的关键字不区分大小写，也就是说，create和CREATE的作用完全一样。 在上面5种SQL语句中，DCL语句用于为数据库用户授权，或者回收指定用户的权限，通常无须程序员操作 在SQL命令中也可能需要使用标识符，标识符可用于定义表名、列名，也可用于定义变量等。这些标识符的命名规则如下。 标识符通常必须以字母开头。 标识符包括字母、数字和三个特殊字符(#_ $)。 不要使用当前数据库系统的关键字、保留字，通常建议使用多个单词连缀而成，单词之间以_分隔。 同一个模式下的对象不应该同名，这里的模式指的是外模式。 truncate是一个特殊的DDL语句，truncate 在很多数据库中都被归类为DDL，它相当于先删除指定的数据表,然后再重建该数据表。如果使用MySQL的普通存储机制, truncate确实是这样的。但如果使用InnoDB存储机制,则比较复杂,在MySQL5.0.3之前, truncate和delete完全一样;在5.0.3之后，truncate table比delete效率高，但如果该表被外键约束所参照，则依然被映射成delete操作。当使用快速truncate时，该操作会重设自动增长计数器。在5.0.13之后，快速truncate总是可用，即比delete性能要好。 DDL语句DDL语句是操作数据库对象的语句，包括创建(create)、删除(drop)和修改(alter) 数据库对象。最基本的数据库对象是数据表，数据表是存储数据的逻辑单元。但数据库里绝不仅包括数据表，数据库里可包含如表所示的几种常见的数据库对象。 对象名称 对应关键字 描述 表 table 表是存储数据的逻辑单元，以行和列的形式存在;列就是字段，行就是记录 数据字典 就是系统表，存放数据库相关信息的表。系统表里的数据通常由数据库系统护，程序员通常不应该手动删除修改系统表数据 约束 constraint 执行数据校验的规则，用于保证数据完整性的规则 视图 view 一个或者多个数据表里数据的逻辑显示。视图并不存储数据 索引 index 用于提高查询性能，相当于书的目录 函数 function 用于完成一次特定的计算，具有一个返回值 存储过程 procedure 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境 触发器 trigger 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理 创建表的语法12345create table [模式名.]表名( #可以有多个列定义 columnName1 datatype [default expr])) 下表为MySQL支持的数据类型 列类型 说明 tinyint/smallint/mediumint/int(integer)/bigint 1字节/2字节/3字节/4字节/8字节整数，又可分为有符号和无符号两种。这些整数类型的区别仅仅是表数范围不同 float/double 单精度、双精度浮点类型 decimal(dec) 精确小数类型，相对于float和double不会产生精度丟失的问题 date 日期类型,不能保存时间。把java.util.Date对象保存进date列时，时间部分将会丢失 time 时间类型,不能保存日期。把java util.Date对象保存进time列时，日期部分将会丢失 datetime 日期、时间类型 timestamp 时间截类型 year 年类型，仅仅保存时间的年份 char 定长字符串类型 varchar 可变长度字符串类型 binary 定长二进制字符串类型，它以二进制形式保存字符串 varbinary 可变长度的二进制字符串类型，它以二进制形式保存字符串 tinyblob/blob/mediumblob/longblob 1字节/2字节/3字节/4字节的二进制大对象,可用于存储图片、音乐等二进制数据，分别可存储: 255B/64KB/6MB/4GB 的大小 tinytext/text/mediumtex/longtext 1字节2字节/3字节/4字节的文本对象，可用于存储超长长度的字符串，分别可存储: 255B/64KB/16MB/4GB大小的文本 enum(‘valuel’,valu2…) 枚举类型，该列的值只能是enum后括号里多个值的其中之一 set(‘valuel’,’value2’…) 集合类型，该列的值可以是set后括号里多个值的其中几个 一例：12345678CREATE TABLE `test_first` ( `test_id` int(11) DEFAULT NULL, `test_price` decimal(10,0) DEFAULT NULL, `test_name` varchar(255) DEFAULT 'xxxx', `test_desc` text, `test_img` blob, `test_date` datetime DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 上面是比较常见的建表语句，这种建表语句只是创建一个空表,该表里没有任何数据。如果使用子查询建表语句，则可以在建表的同时插入数据。子查询建表语句的语法如下:12create table [模式名.]表名 [column[,column...]]as subquery; 上面语法中新表的字段列表必须与子查询中的字段列表数量匹配，创建新表时的字段列表可以省略，如果省略了该字段列表，则新表的列名与选择结果完全相同。下面语句使用子查询来建表。1234# 创建hehe数据表，该数据表和user_ inf完全相同，数据也完全相同create table heheasselect * from user_ inf; 修改变结构语法修改表结构使用alter table,修改表结构包括增加列定义、修改列定义、删除列、重命名列等操作。增加列定义的语法如下:123456alter table 表名add#可以有多个列定义column name_l datatype [default expr]，......); 一例：123456789# 为hehe数据表增加一个hehe id字段，该字段的类型为intalter table heheadd hehe_id int;#量为hehe数据表增加aaa、bbb字段，两个字段的类型都为varchar(255)alter table heheaddaaa varchar (255) default 'xxx',bbb varchar (255)); 增加字段时需要注意:如果数据表中已有数据记录，除非给新增的列指定了默认值,否则新增的数据列不可指定非空约束，因为那些已有的记录在新增列上肯定是空(实际上，修改表结构很容易失败，只要新增的约束与已有数据冲突，修改就会失败)。 修改列的语法如下12alter table 表名modify column name datatype [default expr] [first|after col name ] ; 一例123456#将hehe表的hehe id列修改成varchar (255)类型alter table hehemodify hehe_id varchar(255);单将hehe表的bbb列修改成int类型alter table hehemodify bbb int; 虽然MySQL的一个modify命令不支持一次修改多个列定义,但其他数据库如Oracle支持一个modify命令修改多个列定义,一个modify命令修改多个列定义的语法和一个add命令增加多个列定义的语法非常相似，也需要使用圆括号把多个列定义括起来。如果需要让MySQL支持-次修改多个列定义，则可在alter table后使用多个modify命令。add新增的列名必须是原表中不存在的，而modify修改的列名必须是原表中已存在的。 如果数据表里已有数据记录，则修改列定义非常容易失败，因为有可能修改的列定义规则与原有数据记录不符合。如果修改数据列的默认值，则只会对以后的插入操作有作用，对以前已经存在的数不会有任何影响。12alter table 表名drop column name 重命名数据表的语法格式如下:12alter table 表名rename to 新表名 MySQL为alter table提供了change 选项，该选项可以改变列名。change 选项的语法如下:12alter table 表名change o1d column name new_ column name type [default exprl [firstlafter col name] 对比change和modify两个选项,不难发现: change选项比modify选项多了一个列名，因为change选项可以改变列名，所以它需要两个列名。一般而言，如果不需要改变列名，使用alter table的modify选项即可，只有当需要修改列名时才会使用change选项。如下语句所示:123#将wawa数据表的bbb字段重命名为dddalter table wawachange bbb ddd int; 删除表的语法删除表的语法比较简单1drop table 表名 删除数据表的效果如下： 表结构被删除,表对象不再存在。 表里的所有数据也被删除。 该表所有相关的索引、约束也被删除 truncate 表对于大部分数据库而言,truncate都被当成DDL处理,truncate被称为“截断”某个表。它的作用是删除该表里的全部数据,但保留表结构。相对于DML里的delete命令而言, truncate的速度要快得多,而且truncate不像delete可以删除指定的记录, truncate只能一次性删除整个表的全部记录。truncate命令的语法如下:1truncate 表名 MySQL对truncate的处理比较特殊————如果使用非InnoDB存储机制, truncate比delete速度要快;如果使用 InnoDB存储机制,在 MySQL5.0.3之前,truncate和delete完全一样,在5.0.3之后, truncate table比delete效率高,但如果该表被外键约束所参照, truncate又变为delete操作。在5.0.13之后,快速truncate总是可用,即比delete性能要好。 数据库约束前面创建的数据表仅仅指定了一些列定义,这仅仅是数据表的基本功能。除此之外,所有的关系数据库都支持对数据表使用约束,通过约束可以更好地保证数据表里数据的完整性。约束是在表上强制执行的数据校验规则,约束主要用于保证数据库里数据的完整性。除此之外,当表中数据存在相互依赖性时,可以保护相关的数据不被删除。 大部分数据库支持下面5种完整性约束。 NOT NULL:非空约束,指定某列不能为空。 UNIQUE:唯一约束,指定某列或者几列组合不能重复。 PRIMARY KEY:主键,指定该列的值可以唯一地标识该条记录。 FOREIGN KEY:外键,指定该行记录从属于主表中的一条记录,主要用于保证参照完整性。 CHECK:检查,指定一个布尔表达式,用于指定对应列的值必须满足该表达式 虽然大部分数据库都支持上面5种约束,但MySQL不支持CHECK约束,虽然MySQL的SOL语句也可以使用CHECK约束,但这个CHECK约束不会有任何作用。 虽然约束的作用只是用于保证数据表里数据的完整性,但约束也是数据库对象,并被存储在系统表中,也拥有自己的名字。根据约束对数据列的限制,约束分为如下两类: 单列约束:每个约束只约束一列。 多列约束:每个约束可以约束多个数据列。 为数据表指定约束有如下两个时机。 建表的同时为相应的数据列指定约束。 建表后创建,以修改表的方式来增加约束。 大部分约束都可以采用列级约束语法或者表级约束语法。下面依次介绍5种约束的建立和删除(约束通常无法修改)。 MySQL使用information schema数据库里的TABLE CONSTRAINTS表来保存该数据库实例中所有的约束信息,用户可以通过查询TABLE_CONSTRAINTS表来获取该数据库的约束信息。 NOT NULL约束非空约束用于确保指定列不允许为空，非空约束是比较特殊的约束，它只能作为列级约束使用，只能使用列级约束语法定义。这里要介绍一下SQL中的null值，SQL中的null不区分大小写。SQL中的null具有如下特征。 所有数据类型的值都可以是null, 包括int、 float、boolean等数据类型。 与Java类似的是，空字符串不等于null, 0也不等于null。如果需要在建表时为指定列指定非空约束，只要在列定义后增加not null即可。 建表语句如下:123456789create table hehe( #建立了非空约束，这意味着hehe_id不可以为null hehe id int not null, # MySQL的非空约束不能指定名字 hehe name varchar (255) default 'xyz' not nul1 , #下面列可以为空，默认就是可以为空 hehe gender varchar (2) nul1); 除此之外，也可以在使用alter table修改表时增加或者删除非空约束，SQL 命令如下:123456789#增加非空约束alter table hehemodify hehe gender varchar (2) not null#取消非空约束alter table hehemodify hehe name varchar(2) null;#取消非空约束，并指定默认值alter table hehemodify hehe name varchar (255) default ‘abc' null; UNIQUE约束唯一约束用于保证指定列或指定列组合不允许出现重复值。虽然唯一约束的列不可以出现重复值，但可以出现多个null值(因为在数据库中null不等于null)。 同一个表内可建多个唯一约束， 唯一约束也可由多列组合而成。当为某列创建唯一约束时, MySQL会为该列相应地创建唯一索引。 如果不给唯一约束起名，该唯一约束默认与列名相同。 唯一约束既可以使用列级约束语法建立,也可以使用表级约束语法建立。如果需要为多列建组合约束，或者需要为唯一约束指定约束名，则只能用表级约束语法。 当建立唯一约束时，MySQL 在唯一约束所在列或列组合上建立对应的唯一索引。 使用列级约束语法建立唯一约束非常简单，只要简单地在列定义后增加unique关键字即可。SQL语句如下: 12345678#建表时创建唯一约束，使用列级约束语法建立约束create table unique_test( #建立了非空约束，这意味着test_id不可以为null test_id int not null, #unique就是唯一约束，使用列级约束语法建立唯一约束 test_name varchar (255) unique); 如果需要为多列组合建立唯一约束,或者想自行指定约束名，则需要使用表级约束语法。1[constraint 约束名]约束定义 上面的表级约束语法格式既可放在create table语句中与列定义并列，也可放在alter table语句中使用add关键字来添加约束。123456789101112#建表时创建唯约束，使用表级约束语法建立约束create table unique_test2( #建立了非空约束，这意味着test_id不可以为null test_id int not null, test_name varchar (255) , test_pass varchar (255) , #使用表级约束语法建立唯一约束 unique (test_name)， #使用表级约束语法建立唯一约束，而且指定约束名 constraint test2_uk unique(test_pass)); 上面的建表语句为test_name、test_pass 分别建立了唯一约束， 这意味着这两列都不能出现重复值。除此之外，还可以为这两列组合建立唯一约束。12345678910#建表时创建唯一约束，使用表级约束语法建立约束create table unique_test3(#建立了非空约束，这意味着test_id不可以为nulltest_id int not null,test_name varchar (255) ,test_pass varchar (255)，#使用表级约束语法建立唯一约束，指定两列组合不允许重复constraint test3_uk unique(test_name,test_pass)); 对于上面的unique_test2 和unique_test3两个表,都是对test_ name、test_pass建立唯一约束，其中unique_test2要求test_ name、test_pass都不能出现重复值，而unique_test3只要求test_name、test_pass两列值的组合不能重复。 也可以在修改表结构时使用add关键字来增加唯一约束123#增加唯一约束alter table unique_test3add unique (test_name, test_pass) ; 还可以在修改表时使用modify关键字，为单列采用列级约束语法来增加唯一约束:123#为unique_test3表的test_name列增加唯约束alter table unique_test3modify test name varchar(255) unique; 对于大部分数据库而言,删除约束都是在alter table语句后使用drop constraint约束名语法来完成的，但MySQL并不使用这种方式，而是使用“drop index约束名”的方式来删除约束。例如如下SQL语句:123#删除unique_test3表上的test3_uk唯约束alter table unique_test3drop index test3_uk; PRIMARY KEY约束主键约束相当于非空约束和唯一约束， 即主键约束的列既不允许出现重复值，也不允许出现null值;如果对多列组合建立主键约束,则多列里包含的每一列都不能为空，但只要求这些列组合不能重复。主键列的值可用于唯一地标识表中的一条记录。 每一个表中最多允许有一个主键,但这个主键约束可由多个数据列组合而成，主键是表中能唯一确定一行记录的字段或字段组合。 建立主键约束时既可使用列级约束语法，也可使用表级约束语法。如果需要对多个字段建立组合主键约束，则只能使用表级约束语法。使用表级约束语法来建立约束时，可以为该约束指定约束名。但不管用户是否为该主键约束指定约束名，MySQL总是将所有的主键约束命名为PRIMARY。 建表时创建主键约束，使用列级约束语法:123456create table primary_ test( #建立了主键约束 test id int primary key, test_ name varchar (255)); 建表时创建主键约束，使用表级约束语法:12345678create table primary_test2( test_id int not null, test_name varchar (255) , test_pass varchar (255) , #井指定主键约束名为test2_pk,对大部分数据库有效,但对MySQL无效 #MySQL数据库中该主键约束名依然是PRIMARY constraint test2_pk primary key(test_id) ); 建表时创建主键约束，以多列建立组合主键，只能使用表级约束语法:1234567create table primary_test3（ test_name varchar (255)， test_pass varchar (255) , 并建立多列组合的主键约束 primary key(test_name, test_pass) ); 如果需要删除指定表的主键约束,则在alter table 语句后使用drop primary key子句即可。SQL语如下:123#删除主键约束alter table primary test3drop primary key; 如果需要为指定表增加主键约束，既可通过modify修改列定义来增加主键约束，这将采用列级约束语法来增加主键约束;也可通过add来增加主键约束，这将采用表级约束语法来增加主键约束。SQL语句如下:普使用表级约束语法增加主键约束12alter table primary_test3add primary key(test_name, test_pass); 如果只是为单独的数据列增加主键约束,则可使用modify修改列定义来实现:123#使用列级约束语法增加主键约束alter table primary test3modify test name varchar (255) primary key; 不要连续执行上面两条SQL语句，因为上面两条SQL语句都是为primary_test3增加主键约束，而同一个表里最多只能有一个主键约束，所以连续执行上面两条SQL语句肯定出现错误。为了避免这个问题，可以在成功执行了第一条增加主键约束的SQL语句之后，先将primary_test3里的主键约束删除后再执行第二条增加主键约束的SQL语句。 很多数据库对主键列都支持一种自增长的特性,如果某个数据列的类型是整型,而且该列作为主键列，则可指定该列具有自增长功能。指定自增长功能通常用于设置逻辑主键列,该列的值没有任何物理意义，仅仅用于标识每行记录。MySQL使用auto_increment来设置自增长.123456create table primary_test4 #建立主键约束，使用自增长 test_id int auto_increment primary key, test_name varchar (255)， test_pass varchar (255)); 一旦指定了某列具有自增长特性，则向该表插入记录时可不为该列指定值,该列的值由数据库系统自动生成。 FOREIGN KEY 约束外键约束主要用于保证一个或两个数据表之间的参照完整性,外键是构建于一个表的两个字段或者两个表的两个字段之间的参照关系。外键确保了相关的两个字段的参照关系:子(从)表外键列的值必须在主表被参照列的值范围之内，或者为空(也可以通过非空约束来约束外键列不允许为空)。 当主表的记录被从表记录参照时，主表记录不允许被删除，必须先把从表里参照该记录的所有记录全部删除后，才可以删除主表的该记录。还有一种方式,删除主表记录时级联删除从表中所有参照该记录的从表记录。 从表外键参照的只能是主表主键列或者唯一键列,这样才可保证从表记录可以准确定位到被参照的主表记录。同一个表内可以拥有多个外键。 建立外键约束时，MySQL也会为该列建立索引。 外键约束通常用于定义两个实体之间的一对多、一对一的关联关系。对于一对多的关联关系,通常在多的一端增加外键列，例如老师一学生(假设一个老师对应多个学生，但每个学生只有一个老师,这是典型的一对多的关联关系)。为了建立他们之间的关联关系，可以在学生表中增加一个外键列，该列中保存此条学生记录对应老师的主键。对于一对一的关联关系，则可选择任意一方来增加外键列,增加外键列的表被称为从表,只要为外键列增加唯一约束就可表示一对一的关联关系了。对于多对多的关联关系，则需要额外增加一个连接表来记录它们的关联关系。 建立外键约束同样可以采用列级约束语法和表级约束语法。如果仅对单独的数据列建立外键约束，则使用列级约束语法即可;如果需要对多列组合创建外键约束，或者需要为外键约束指定名字,则必须使用表级约束语法。 采用列级约束语法建立外键约束直接使用references关键字, references 指定该列参照哪个主表，以及参照主表的哪一列。1234567891011121314#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table( #auto_increment: 代表数据库的自动编号策略，通常用作数据表的 逻辑主键 teacher_id int auto_increment, teacher_name varchar(255), primary_key(teacher_id));create table student_table(#为本表建立主键约束student_id int auto_increment primary key,student_name varchar(255)，#指定java_teacher参照到teacher_table的teacher_id列java_teacher int references teacher_table (teacher id)); 值得指出的是，虽然MySQL支持使用列级约束语法来建立外键约束,但这种列级约束语法建立的外键约束不会生效，MySQL提供这种列级约束语法仅仅是为了和标准SQL保持良好的兼容性。因此，如果要使MySQL中的外键约束生效，则应使用表级约束语法。 12345678910111213141516#为了保证从表参照的主表存在，通常应该先建主表create table teacher_tablel(#auto_increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键 teacher_id int auto_increment, teacher_name varchar(255), primary key (teacher_id));create table student_table1( #为本表建立主键约束 student_id int auto_increment primary key, student_name varchar (255)， #指定java_teacher参照到teacher_tablel的teacher_id列 java_teacher int, foreign key(java_teacher) references teacher_tablel (teacher_id)); 如果使用表级约束语法，则需要使用foreige key来指定本表的外键列，并使用references来指定参照哪个主表，以及参照到主表的哪个数据列。使用表级约束语法可以为外键约束指定约束名,如果创建外键约束时没有指定约束名，则MySQL会为该外键约束命名为table_name_ibfk_n, 其中table_name 是从表的表名，而n是从1开始的整数。 如果需要显式指定外键约束的名字，则可使用constraint来指定名字。1234567891011121314#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table2#auto increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键teacher_id int auto_increment,teacher_name varchar(255) ,primary key (teacher_id));create table student_table2#为本表建立主键约束student_id int auto_increment primary key,student_name varchar(255)，java_teacher int,#使用表级约束语法建立外键约束，指定外键约束的约束名为student_ teacher_fkconstraint student_teacher_fk foreign key (java_teacher) references teacher_table2 (teacher_id)); 如果需要建立多列组合的外键约束，则必须使用表级约束语法，如下SQL语句所示:123456789101112131415161718#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table3( teacher_name varchar(255) , teacher_pass varchar(255) , #以两列建立组合主键 primary key(teacher_name，teacher_pass));create table student_table3#为本表建立主键约束student_id int auto_increment primary key,student_name varchar (255) ,java_teacher_name varchar (255) ,java_teacher_pass varchar (255) ,#使用表级约束语法建立外键约束，指定两列的联合外键foreign key(java_teacher_name，java_teacher_pass)references teacher_table3 (teacher_name，teacher_pass)); 删除外键约束的语法很简单，在alter table后增加“drop foreign key约束名”子句即可。如下代码所示:12#删除student_table3表上名为student_table3_ibfk_1的外键约束alter table student table3drop foreign key student_table3_ibfk_1; 增加外键约束通常使用add foreign key命令。如下SQL语句所示:1234#修改student_table3数据表，增加外键约束alter table student_table3add foreign key(java_teacher_name，java_teacher_pass)references teacher_table3 (teacher_name，teacher_pass); 值得指出的是，外键约束不仅可以参照其他表，而且可以参照自身，这种参照自身的情况通常被称为自关联。例如，使用一个表保存某个公司的所有员工记录，员工之间有部门经理和普通员工之分，部门经理和普通员工之间存在一”对 多的关联关系，但他们都是保存在同一个数据表里的记录，这就是典型的自关联。下面的SQL语句用于建立自关联的外键约束。12345678#使用表级约束语法建立外约束键，且直接参照自身create table foreign_testforeign_id int auto increment primary key,foreign_name varchar (255)，#使用该表的refer_id参照到本表的foreign id列refer_id int,foreign key(refer_id) references foreign_test(foreign_id)); 如果想定义当删除主表记录时，从表记录也会随之删除，则需要在建立外键约束后添加on delete cascade或添加on delete set null,第-种是删除主表记录时，把参照该主表记录的从表记录全部级联删除;第二种是指定当删除主表记录时，把参照该主表记录的从表记录的外键设为null。如下SQL语句所示:1234567891011121314151617#为了保证从表参照的主表存在，通常应该先建主表create table teacher_table4( # auto_increment:代表数据库的自动编号策略，通常用作数据表的逻辑主键 teacher_id int auto_increment, teacher_name varchar(255)， primary key(teacher_id) ); create table student_table4 #为本表建立主键约束 student_id int auto_increment primary key, student_name varchar (255)， java_teacher int, #使用表级约束语法建立外键约束，定义级联删除 foreign key(java_teacher) references teacher_table4 (teacher id) on delete cascade #也可用on delete set null); CHECK 约束当前版本的MySQL支持建表时指定CHECK约束,但这个CHECK约束不会有任何作用。建立CHECK约束的语法很简单，只要在建表的列定义后增加check(逻辑表达式)即可。如下SQL语句所示:12345678create table check_test emp_id int auto_increment, emp_name varchar(255), emp_salary decimal, primary key(emp_id) ， #普建立CHECK约束 check (emp_salary&gt;0)); 虽然上面的SQL语句建立的check_test表中有CHECK约束, CHECK约束要求emp_salary大于0,但这个要求实际上并不会起作用。 索引索引是存放在模式(schema)中的一个数据库对象，虽然索引总是从属于数据表，但它也和数据表一样属于数据库对象。创建索引的唯一作用就是加速对表的查询,索引通过使用快速路径访问方法来快速定位数据，从而减少了磁盘的I/O。索引作为数据库对象，在数据字典中独立存放，但不能独立存在，必须属于某个表。MySQL使用information_schema数据库里的STATISTICS表来保存该数据库实例中的所有索引信息，用户可通过查询该表来获取该数据库的索引信息。 创建索引有两种方式。 自动:当在表上定义主键约束、唯一约束和外键约束时，系统会为该数据列自动创建对应的索引。 手动:用户可以通过create index…语句来创建索引。 删除索引也有两种方式。 自动:数据表被删除时，该表上的索引自动被删除。 手动:用户可以通过drop index…语句来删除指定数据表上的指定索引。 索引的作用类似于书的目录，几乎没有一本书没有目录，因此几乎没有一个表没有索引。一个表中可以有多个索引列，每个索引都可用于加速该列的查询速度。 正如书的目录总是根据书的知识点来建立一样因为读者经常要根据知识点来查阅一本书。类似的, 通常为经常需要查询的数据列建立索引，可以在一列或者多列上创建索引。创建索引的语法格式如下:12create index index_nameon table name(column[, column]...); 下面的索引将会提高对employees表基于last_name字段的查询速度。12create index emp_last_name_idxon employees(1ast_name) ; 也可同时对多列建立索引，如下SQL语句所示:123#下面语句为employees的first_name和last_name两列同时建立索引create index emp_last_name_idx2on employees (first_name, last_name); MySQL中删除索引需要指定表，采用如下语法格式:1drop index索引名on表名 如下SQL语句删除了employees表上的emp_last_name_idx2索引:12drop index emp_last_name_idx2on employees 有些数据库删除索引时无须指定表名,因为它们要求建立索引时每个索引都有唯一的名字, 所以无须指定表名，例如Oracle就采用这种策略。但MySQL只要求同一个表内的索引不能同名，所以删除索引时必须指定表名。索引的好处是可以加速查询。但索引也有如下两个坏处。 与书的目录类似，当数据表中的记录被添加、删除、修改时，数据库系统需要维护索引，因此有一定的系统开销。 存储索引信息需要-一定的磁盘空间。 视图视图看上去非常像一个数据表，但它不是数据表，因为它并不能存储数据。视图只是一个或多个数据表中数据的逻辑显示。使用视图有如下几个好处。 可以限制对数据的访问。 可以使复杂的查询变得简单。 提供了数据的独立性。 提供了对相同数据的不同显示。因为视图只是数据表中数据的逻辑显示————也就是一个查询结果,所以创建视图就是建立视图名和查询语句的关联。创建视图的语法如下:123create or replace view视图名assubquery 从上面的语法可以看出，创建、修改视图都可使用上面语法。上面语法的含义是,如果该视图不存在，则创建视图;如果指定视图名的视图已经存在，则使用新视图替换原有视图。后面的subquery就是一个查询语句，这个查询可以非常复杂。通过建立视图的语法规则不难看出，所谓视图的本质，其实就是一条被命名的SQL查询语句。 一旦建立了视图以后，使用该视图与使用数据表就没有什么区别了，但通常只是查询视图数据,不会修改视图里的数据，因为视图本身没有存储数据。如下SQL语句就创建了一个简单的视图:123create or replace view view_testasselect teacher_name，teacher_pass from teacher_table; 通常不推荐直接改变视图的数据,因为视图并不存储数据,它只是相当于一条命名的查询语句而已。为了强制不允许改变视图的数据，MySQL 允许在创建视图时使用with check option 子句，使用该子句创建的视图不允许修改，如下所示:12345create or replace view view_testasselect teacher_name from teacher_table#指定不允许修改该视图的数据with check option; 大部分数据库都采用with check option来强制不允许修改视图的数据，但Oracle采用with read only来强制不允许修改视图的数据. 删除视图使用如下语句:1drop view 视图名 如下SQL语句删除了前面刚刚创建的视图:1drop view view_test;","link":"/2019/01/24/MySQL基础/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Database MySQL","slug":"Database-MySQL","link":"/tags/Database-MySQL/"},{"name":"Database | MySQL","slug":"Database-MySQL","link":"/tags/Database-MySQL/"},{"name":"Database,MySQL","slug":"Database-MySQL","link":"/tags/Database-MySQL/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[]}